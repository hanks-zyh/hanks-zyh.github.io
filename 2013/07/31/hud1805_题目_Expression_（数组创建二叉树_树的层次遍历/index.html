<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hud1805 题目 Expression （数组创建二叉树+树的层次遍历 | Hanks&#39; Websit</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <script data-ad-client="ca-pub-8165670162444117" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta name="referrer" content="never">
  <meta name="description" content="&nbsp; &nbsp; Expressions Time Limit: 1000&#x2F;1000 MS (Java&#x2F;Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768&#x2F;32768 K (Java&#x2F;Others) Total Submission(s): 201&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s">
<meta property="og:type" content="article">
<meta property="og:title" content="hud1805 题目 Expression （数组创建二叉树+树的层次遍历">
<meta property="og:url" content="https://hanks.pub/2013/07/31/hud1805_%E9%A2%98%E7%9B%AE_Expression_%EF%BC%88%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91_%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/index.html">
<meta property="og:site_name" content="Hanks&#39; Websit">
<meta property="og:description" content="&nbsp; &nbsp; Expressions Time Limit: 1000&#x2F;1000 MS (Java&#x2F;Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768&#x2F;32768 K (Java&#x2F;Others) Total Submission(s): 201&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.blog.csdn.net/20130731214513281">
<meta property="og:image" content="https://img.blog.csdn.net/20130731214513468">
<meta property="article:published_time" content="2013-07-31T13:58:00.000Z">
<meta property="article:modified_time" content="2024-02-08T01:29:02.187Z">
<meta property="article:author" content="Hanks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.blog.csdn.net/20130731214513281">
  
  
  <link href="https://fonts.googleapis.com/css?family=Fira+Code|Noto+Serif+SC&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8165670162444117"
     crossorigin="anonymous"></script>
  <div id="header-outer" class="outer">
    <a href="/" class="logo"></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="/archives">Archive</a>
      
        <a class="main-nav-link" href="/eye-video">Eye</a>
      
        <a class="main-nav-link" href="/atom.xml">Rss</a>
      
    </nav>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/archives" class="mobile-nav-link">Archive</a>
  
    <a href="/eye-video" class="mobile-nav-link">Eye</a>
  
    <a href="/atom.xml" class="mobile-nav-link">Rss</a>
  
</nav>
      <div class="outer">
        <section id="main"><article id="post-hud1805_题目_Expression_（数组创建二叉树_树的层次遍历" class="article article-type-post" itemscope
  itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
    <header class="article-header">
      
      
  
    <h1 class="article-title" itemprop="name">
      hud1805 题目 Expression （数组创建二叉树+树的层次遍历
    </h1>
  

      
    </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">Expressions</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 1000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 201&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 102<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">Arithmetic expressions are usually written with the operators in between the two operands (which is called infix notation). For example, (x&#43;y)*(z-w) is an arithmetic expression in infix notation. However, it is easier to write a program
 to evaluate an expression if the expression is written in postfix notation (also known as reverse polish notation). In postfix notation, an operator is written behind its two operands, which may be expressions themselves. For example, x y &#43; z w - * is a postfix
 notation of the arithmetic expression given above. Note that in this case parentheses are not required.
<br>
<br>
To evaluate an expression written in postfix notation, an algorithm operating on a stack can be used. A stack is a data structure which supports two operations:
<br>
<br>
1. push: a number is inserted at the top of the stack. <br>
2. pop: the number from the top of the stack is taken out. <br>
During the evaluation, we process the expression from left to right. If we encounter a number, we push it onto the stack. If we encounter an operator, we pop the first two numbers from the stack, apply the operator on them, and push the result back onto the
 stack. More specifically, the following pseudocode shows how to handle the case when we encounter an operator O:
<br>
<br>
a := pop();<br>
b := pop();<br>
push(b O a);<br>
The result of the expression will be left as the only number on the stack. <br>
<br>
Now imagine that we use a queue instead of the stack. A queue also has a push and pop operation, but their meaning is different:
<br>
<br>
1. push: a number is inserted at the end of the queue. <br>
2. pop: the number from the front of the queue is taken out of the queue. <br>
Can you rewrite the given expression such that the result of the algorithm using the queue is the same as the result of the original expression evaluated using the algorithm with the stack?
<br>
</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The first line of the input contains a number T (T ≤ 200). The following T lines each contain one expression in postfix notation. Arithmetic operators are represented by uppercase letters, numbers are represented by lowercase letters.
 You may assume that the length of each expression is less than 10000 characters.
<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each given expression, print the expression with the equivalent result when using the algorithm with the queue instead of the stack. To make the solution unique, you are not allowed to assume that the operators are associative
 or commutative. <br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
xyPzwIM
abcABdefgCDEF</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">wzyxIPM
gfCecbDdAaEBF</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>解题思路:</p>
<p>&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr><a target="_blank" href="https://photo.blog.sina.com.cn/showpic.html#blogid=64018c250100qi0j&amp;url=https://s1.sinaimg.cn/orignal/64018c25g9fdb220d6420" target="_blank"></a><br>
<a target="_blank" href="https://photo.blog.sina.com.cn/showpic.html#blogid=64018c250100qi0j&amp;url=https://s14.sinaimg.cn/orignal/64018c25g9fdb29ad7a0d" target="_blank"></a><img src="https://img.blog.csdn.net/20130731214513281" alt=""><img src="https://img.blog.csdn.net/20130731214513468" alt=""></p>
<p><br>
从图中我们可以发现output &nbsp;<wbr>就是从层序遍历得到的字符串按照逆序输出</p>
<p>&nbsp;</p>
<p>第一次可恶的超时了：</p>
<p>&nbsp;主要是创建数组用的二叉链表，</p>
<pre class="cpp" name="code">typedef struct node
{
      char data;
      node * lchild;
      node * rchild;  
}node;

</pre>
<p><br>
还有队列用的STL标准模板，不知道为什么这也会很费时间;;;;==!</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

typedef struct node
{
      char data;
      node * lchild;
      node * rchild;  
}node;


stack &lt;node *&gt; S;

//int k; 
//char Pnt[10002];


bool is_upper(char c)
{
     if(c&gt;='A' &amp;&amp; c&lt;='Z') return true;
     return false;     
}

node * create_tree(char s[])
{
	node * p;
	node *root;
	int i;
     for(i=0;i&lt;strlen(s);i++)
     {
           if(is_upper(s[i]))
           {
                p = (node*)malloc(sizeof(node));
				p-&gt;data = s[i];
				p-&gt;rchild = S.top(); S.pop();
				p-&gt;lchild = S.top(); S.pop();

				root = p;
				S.push(p);                 
           }              
		   else 
		   {
				p = (node*)malloc(sizeof(node));
				p-&gt;data = s[i];
				p-&gt;lchild = NULL;
				p-&gt;rchild = NULL;
				S.push(p);
			}    
     }
     return root;
}

void BFS(node * root)
{
	queue &lt;node *&gt; Q;
	Q.push(root);
	while(!Q.empty()) 
	{
		printf(&quot;%c&quot;,Q.front()-&gt;data);
		if(Q.front()-&gt;lchild) Q.push(Q.front()-&gt;lchild);
		if(Q.front()-&gt;rchild) Q.push(Q.front()-&gt;rchild);
		//Pnt[k++] = 	Q.front()-&gt;data;		
		Q.pop();	
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i;char s[10002];
    node *root;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
        gets(s); 
        root = create_tree(s);	 	
        BFS(root);             
		printf(&quot;\n&quot;);
    }
 //   system(&quot;pause&quot;);
    return 0;    
}


</pre>
<p><br>
f第二次：南开oj 通过，因为限时2000MS ，&nbsp; 改进代码时间 1500MS&nbsp; ，但是对于杭电oj，POJ都不行，还超时，</p>
<p>其中放弃二叉链表创建数组，而是用一个 结构体数组，存放孩子信息，</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

typedef struct TREE 
{
	char dat;
	int l,r;	
}TREE;

TREE tree[10002];

stack &lt;int&gt; S;

int k; 
char Pnt[10002];


bool is_upper(char c)
{
     if(c&gt;='A' &amp;&amp; c&lt;='Z') return true;
     return false;     
}

void create_tree(char s[])
{
	
	node * p;
	node *root;
	int i;
    for(i=0;i&lt;strlen(s);i++)
    {
		tree[i].dat=s[i];
       if(is_upper(s[i]))
       {
			tree[i].r = S.top(); S.pop();
			tree[i].l = S.top(); S.pop();
			S.push(i);
//               p = (node*)malloc(sizeof(node));
//				p-&gt;data = s[i];
//				p-&gt;rchild = S.top(); S.pop();
//				p-&gt;lchild = S.top(); S.pop();
//
//				root = p;
//				S.push(p);    
			             
       }              
	   else 
	   {
			tree[i].r = -1;
			tree[i].l = -1;
			S.push(i);
		//	p = (node*)malloc(sizeof(node));
//				p-&gt;data = s[i];
//				p-&gt;lchild = NULL;
//				p-&gt;rchild = NULL;
//				S.push(p);
		}    
     }
    // return root;
}

void BFS(char s[])
{
	queue &lt;int&gt; Q;
	Q.push(strlen(s)-1);
	while(!Q.empty()) 
	{
		Pnt[k++] = 	tree[Q.front()].dat;
	//	printf(&quot;%c&quot;,tree[Q.front()].dat);
		if(tree[Q.front()].l != -1) Q.push(tree[Q.front()].l);
		if(tree[Q.front()].r != -1) Q.push(tree[Q.front()].r);
				
		Q.pop();	
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i;char s[10002];
    node *root;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
		k=0;
        gets(s); 
        create_tree(s);	 	
        BFS(s);  
      //  printf(&quot;\n&quot;);
		Pnt[k]='\0'; 
		for(i=strlen(Pnt)-1;i&gt;=0;i--) printf(&quot;%c&quot;,Pnt[i]);          
		printf(&quot;\n&quot;);
    }
   // system(&quot;pause&quot;);
    return 0;    
}


</pre>
<p>第三次改进： 就放弃STLqueue 用一个一位数组表示队列，（我不知道是不是这里的原因，，，时间一下子减少不少），如果有大神知道的话，混应知道</p>
<p>time： 20MS，，这次到哪里都可以AC，无压力了；；；</p>
<pre class="cpp" name="code">#define N 10005
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
typedef struct TREE 
{
	int l,r,own;	
}TREE;

TREE tree[N];
char Pnt[N],s[N];
int Stack[N],Q[N];

void build_tree(int n)
{
	int i,top=-1;
	memset(tree,-1,sizeof(tree));
	for(i=0;i&lt;n;i++)
	{
		if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')//小写 
		Stack[++top]=i;
		else{
			tree[i].r = Stack[top--];
			tree[i].l = Stack[top];
			Stack[top]= i;
		}
		tree[i].own = i;
	}
}
void BFS(int n)
{	

	int front=0,rear=1,k=0; 
	for(Q[0]=n;front&lt;rear;front++)
	{
		TREE u = tree[Q[front]];
	//	printf(&quot;front=%d,c=%c\n&quot;,front,s[u.own]);
		Pnt[k++]= s[u.own];
		if(u.l != -1) Q[rear++] = u.l;
		if(u.r != -1) Q[rear++] = u.r;					
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i,k;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
        gets(s);
       // printf(&quot;len=%d\n&quot;,strlen(s));
        int n = strlen(s);
        build_tree(n);
        BFS(n-1); 
 
		for(i=n-1;i&gt;=0;i--) printf(&quot;%c&quot;,Pnt[i]);          
		printf(&quot;\n&quot;);
			
    }
  // system(&quot;pause&quot;);
    return 0;    
}

</pre>
<p><br>
<br>
&nbsp;</p>
<p>&nbsp;</p>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
</article>

<!-- 上一页 下一页 -->


<nav id="article-nav">
  
    <a href="/2013/08/01/POJ_%E9%A2%98%E7%9B%AE3253_Fence_Repair_%EF%BC%88%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%BA%94%E7%94%A8%EF%BC%89/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left"></i><span>上一篇</span>
      <div class="article-nav-title">
        
          POJ 题目3253 Fence Repair （赫夫曼树应用）
        
      </div>
    </a>
  
  
    <a href="/2013/07/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%89_SJTU_OJ_%E9%A2%98%E7%9B%AE_1040%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left"></i><span>下一篇</span>
      <div class="article-nav-title">二叉树的层次遍历（相当于广度遍历） SJTU OJ 题目 1040二叉树层次遍历</div>
    </a>
  
</nav>



<!-- 相关文章 -->

<!--

-->


</section>
      </div>
      <footer id="footer">
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      
      &copy;2025<a target="_blank" rel="noopener" href="https://github.com/hanks-zyh"> Hanks</a>版权所有
      <br/>
      <a href="https://beian.miit.gov.cn/" target="_blank">豫ICP备2021022347号</a>
	  </div>
  </div>
 <div id="share">
  <a id="totop" title="" style="display: block;">返回顶部</a>
 </div>
</footer>

    </div>
    


<script src="/js/jquery.min.js"></script>


<script src="/js/jquery.scrollLoading.js"></script>





<script src="/js/script.js"></script>


<script src="/js/ads.js"></script>

  </div>
</body>
</html>
