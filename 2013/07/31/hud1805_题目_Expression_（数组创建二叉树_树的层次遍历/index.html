<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hud1805 题目 Expression （数组创建二叉树+树的层次遍历 | Hanks.xyz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="article">
<meta property="og:title" content="hud1805 题目 Expression （数组创建二叉树+树的层次遍历">
<meta property="og:url" content="http://hanks.xyz/2013/07/31/hud1805_题目_Expression_（数组创建二叉树_树的层次遍历/index.html">
<meta property="og:site_name" content="Hanks.xyz">
<meta property="og:description">
<meta property="og:image" content="http://img.blog.csdn.net/20130731214513281">
<meta property="og:image" content="http://img.blog.csdn.net/20130731214513468">
<meta property="og:updated_time" content="2015-12-04T17:20:04.312Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hud1805 题目 Expression （数组创建二叉树+树的层次遍历">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">Hanks.xyz</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about/index.html">关于</a>
        
          <a class="main-nav-link" href="/atom.xml">RSS</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanks.xyz"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/hanks-zyh" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about/index.html" class="mobile-nav-link">关于</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanks.xyz"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/29/react-userinfo/">React-Native 练习用户信息界面</a>
          </li>
        
          <li>
            <a href="/2015/12/29/react-viewpager/">React-Native 实现Android中的ViewPager</a>
          </li>
        
          <li>
            <a href="/2015/12/24/react-navigator/">React-Native 的Navigator控制界面跳转</a>
          </li>
        
          <li>
            <a href="/2015/12/23/react-network/">React-Native 网络请求</a>
          </li>
        
          <li>
            <a href="/2015/12/22/react-components/">React-Native 组件练习-购物app侧滑菜单</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/">Android</a> <a href="/tags/Atom/">Atom</a> <a href="/tags/Java/">Java</a> <a href="/tags/OS-X/">OS X</a> <a href="/tags/React-Native/">React-Native</a> <a href="/tags/Refactoring/">Refactoring</a> <a href="/tags/Rx/">Rx</a> <a href="/tags/RxJava/">RxJava</a> <a href="/tags/Rxandroid/">Rxandroid</a> <a href="/tags/Rxjava/">Rxjava</a> <a href="/tags/Ubuntu/">Ubuntu</a> <a href="/tags/mac-os/">mac os</a> <a href="/tags/virtualBox/">virtualBox</a> <a href="/tags/必备知识/">必备知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://kiya.space">kiya-z</a>
          </li>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main"><article id="post-hud1805_题目_Expression_（数组创建二叉树_树的层次遍历" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/07/31/hud1805_题目_Expression_（数组创建二叉树_树的层次遍历/" class="article-date">
  <time datetime="2013-07-31T13:58:00.000Z" itemprop="datePublished">2013-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      hud1805 题目 Expression （数组创建二叉树+树的层次遍历
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 align="center" style="color:#1a5cc8">Expressions</h1>
<p align="center"><span size="&#43;0"><strong><span style="font-family:Arial; font-size:12px; color:green; font-weight:bold">Time Limit: 1000/1000 MS (Java/Others)&nbsp;&nbsp;&nbsp;&nbsp;Memory Limit: 32768/32768 K (Java/Others)<br>
Total Submission(s): 201&nbsp;&nbsp;&nbsp;&nbsp;Accepted Submission(s): 102<br>
</span></strong></span><br>
<br>
</p>
<div class="panel_title" align="left">Problem Description</div>
<div class="panel_content">Arithmetic expressions are usually written with the operators in between the two operands (which is called infix notation). For example, (x&#43;y)*(z-w) is an arithmetic expression in infix notation. However, it is easier to write a program
 to evaluate an expression if the expression is written in postfix notation (also known as reverse polish notation). In postfix notation, an operator is written behind its two operands, which may be expressions themselves. For example, x y &#43; z w - * is a postfix
 notation of the arithmetic expression given above. Note that in this case parentheses are not required.
<br>
<br>
To evaluate an expression written in postfix notation, an algorithm operating on a stack can be used. A stack is a data structure which supports two operations:
<br>
<br>
1. push: a number is inserted at the top of the stack. <br>
2. pop: the number from the top of the stack is taken out. <br>
During the evaluation, we process the expression from left to right. If we encounter a number, we push it onto the stack. If we encounter an operator, we pop the first two numbers from the stack, apply the operator on them, and push the result back onto the
 stack. More specifically, the following pseudocode shows how to handle the case when we encounter an operator O:
<br>
<br>
a := pop();<br>
b := pop();<br>
push(b O a);<br>
The result of the expression will be left as the only number on the stack. <br>
<br>
Now imagine that we use a queue instead of the stack. A queue also has a push and pop operation, but their meaning is different:
<br>
<br>
1. push: a number is inserted at the end of the queue. <br>
2. pop: the number from the front of the queue is taken out of the queue. <br>
Can you rewrite the given expression such that the result of the algorithm using the queue is the same as the result of the original expression evaluated using the algorithm with the stack?
<br>
</div>
<div class="panel_title" align="left">Input</div>
<div class="panel_content">The first line of the input contains a number T (T ≤ 200). The following T lines each contain one expression in postfix notation. Arithmetic operators are represented by uppercase letters, numbers are represented by lowercase letters.
 You may assume that the length of each expression is less than 10000 characters.
<br>
</div>
<div class="panel_title" align="left">Output</div>
<div class="panel_content">For each given expression, print the expression with the equivalent result when using the algorithm with the queue instead of the stack. To make the solution unique, you are not allowed to assume that the operators are associative
 or commutative. <br>
</div>
<div class="panel_title" align="left">Sample Input</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">2
xyPzwIM
abcABdefgCDEF</div></pre>
</div>
<div class="panel_bottom">&nbsp;</div>
<div class="panel_title" align="left">Sample Output</div>
<div class="panel_content">
<pre><div style="font-family:Courier New,Courier,monospace">wzyxIPM
gfCecbDdAaEBF</div></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>解题思路:</p>
<p>&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr>&nbsp;&nbsp;<wbr><a target="_blank" href="http://photo.blog.sina.com.cn/showpic.html#blogid=64018c250100qi0j&amp;url=http://s1.sinaimg.cn/orignal/64018c25g9fdb220d6420"></a><br>
<a target="_blank" href="http://photo.blog.sina.com.cn/showpic.html#blogid=64018c250100qi0j&amp;url=http://s14.sinaimg.cn/orignal/64018c25g9fdb29ad7a0d"></a><img src="http://img.blog.csdn.net/20130731214513281" alt=""><img src="http://img.blog.csdn.net/20130731214513468" alt=""></p>
<p><br>
从图中我们可以发现output &nbsp;<wbr>就是从层序遍历得到的字符串按照逆序输出</p>
<p>&nbsp;</p>
<p>第一次可恶的超时了：</p>
<p>&nbsp;主要是创建数组用的二叉链表，</p>
<pre class="cpp" name="code">typedef struct node
{
      char data;
      node * lchild;
      node * rchild;  
}node;

</pre>
<p><br>
还有队列用的STL标准模板，不知道为什么这也会很费时间;;;;==!</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

typedef struct node
{
      char data;
      node * lchild;
      node * rchild;  
}node;


stack &lt;node *&gt; S;

//int k; 
//char Pnt[10002];


bool is_upper(char c)
{
     if(c&gt;='A' &amp;&amp; c&lt;='Z') return true;
     return false;     
}

node * create_tree(char s[])
{
	node * p;
	node *root;
	int i;
     for(i=0;i&lt;strlen(s);i++)
     {
           if(is_upper(s[i]))
           {
                p = (node*)malloc(sizeof(node));
				p-&gt;data = s[i];
				p-&gt;rchild = S.top(); S.pop();
				p-&gt;lchild = S.top(); S.pop();

				root = p;
				S.push(p);                 
           }              
		   else 
		   {
				p = (node*)malloc(sizeof(node));
				p-&gt;data = s[i];
				p-&gt;lchild = NULL;
				p-&gt;rchild = NULL;
				S.push(p);
			}    
     }
     return root;
}

void BFS(node * root)
{
	queue &lt;node *&gt; Q;
	Q.push(root);
	while(!Q.empty()) 
	{
		printf(&quot;%c&quot;,Q.front()-&gt;data);
		if(Q.front()-&gt;lchild) Q.push(Q.front()-&gt;lchild);
		if(Q.front()-&gt;rchild) Q.push(Q.front()-&gt;rchild);
		//Pnt[k++] = 	Q.front()-&gt;data;		
		Q.pop();	
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i;char s[10002];
    node *root;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
        gets(s); 
        root = create_tree(s);	 	
        BFS(root);             
		printf(&quot;\n&quot;);
    }
 //   system(&quot;pause&quot;);
    return 0;    
}


</pre>
<p><br>
f第二次：南开oj 通过，因为限时2000MS ，&nbsp; 改进代码时间 1500MS&nbsp; ，但是对于杭电oj，POJ都不行，还超时，</p>
<p>其中放弃二叉链表创建数组，而是用一个 结构体数组，存放孩子信息，</p>
<pre class="cpp" name="code">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
using namespace std;

typedef struct TREE 
{
	char dat;
	int l,r;	
}TREE;

TREE tree[10002];

stack &lt;int&gt; S;

int k; 
char Pnt[10002];


bool is_upper(char c)
{
     if(c&gt;='A' &amp;&amp; c&lt;='Z') return true;
     return false;     
}

void create_tree(char s[])
{
	
	node * p;
	node *root;
	int i;
    for(i=0;i&lt;strlen(s);i++)
    {
		tree[i].dat=s[i];
       if(is_upper(s[i]))
       {
			tree[i].r = S.top(); S.pop();
			tree[i].l = S.top(); S.pop();
			S.push(i);
//               p = (node*)malloc(sizeof(node));
//				p-&gt;data = s[i];
//				p-&gt;rchild = S.top(); S.pop();
//				p-&gt;lchild = S.top(); S.pop();
//
//				root = p;
//				S.push(p);    
			             
       }              
	   else 
	   {
			tree[i].r = -1;
			tree[i].l = -1;
			S.push(i);
		//	p = (node*)malloc(sizeof(node));
//				p-&gt;data = s[i];
//				p-&gt;lchild = NULL;
//				p-&gt;rchild = NULL;
//				S.push(p);
		}    
     }
    // return root;
}

void BFS(char s[])
{
	queue &lt;int&gt; Q;
	Q.push(strlen(s)-1);
	while(!Q.empty()) 
	{
		Pnt[k++] = 	tree[Q.front()].dat;
	//	printf(&quot;%c&quot;,tree[Q.front()].dat);
		if(tree[Q.front()].l != -1) Q.push(tree[Q.front()].l);
		if(tree[Q.front()].r != -1) Q.push(tree[Q.front()].r);
				
		Q.pop();	
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i;char s[10002];
    node *root;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
		k=0;
        gets(s); 
        create_tree(s);	 	
        BFS(s);  
      //  printf(&quot;\n&quot;);
		Pnt[k]='\0'; 
		for(i=strlen(Pnt)-1;i&gt;=0;i--) printf(&quot;%c&quot;,Pnt[i]);          
		printf(&quot;\n&quot;);
    }
   // system(&quot;pause&quot;);
    return 0;    
}


</pre>
<p>第三次改进： 就放弃STLqueue 用一个一位数组表示队列，（我不知道是不是这里的原因，，，时间一下子减少不少），如果有大神知道的话，混应知道</p>
<p>time： 20MS，，这次到哪里都可以AC，无压力了；；；</p>
<pre class="cpp" name="code">#define N 10005
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
typedef struct TREE 
{
	int l,r,own;	
}TREE;

TREE tree[N];
char Pnt[N],s[N];
int Stack[N],Q[N];

void build_tree(int n)
{
	int i,top=-1;
	memset(tree,-1,sizeof(tree));
	for(i=0;i&lt;n;i++)
	{
		if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z')//小写 
		Stack[++top]=i;
		else{
			tree[i].r = Stack[top--];
			tree[i].l = Stack[top];
			Stack[top]= i;
		}
		tree[i].own = i;
	}
}
void BFS(int n)
{	

	int front=0,rear=1,k=0; 
	for(Q[0]=n;front&lt;rear;front++)
	{
		TREE u = tree[Q[front]];
	//	printf(&quot;front=%d,c=%c\n&quot;,front,s[u.own]);
		Pnt[k++]= s[u.own];
		if(u.l != -1) Q[rear++] = u.l;
		if(u.r != -1) Q[rear++] = u.r;					
	}	
}
/*
2
xyPzwIM
abcABdefgCDEF
*/
int main()
{
    int t,i,k;
    scanf(&quot;%d&quot;,&amp;t);
    getchar();
    while(t--)
    {
        gets(s);
       // printf(&quot;len=%d\n&quot;,strlen(s));
        int n = strlen(s);
        build_tree(n);
        BFS(n-1); 
 
		for(i=n-1;i&gt;=0;i--) printf(&quot;%c&quot;,Pnt[i]);          
		printf(&quot;\n&quot;);
			
    }
  // system(&quot;pause&quot;);
    return 0;    
}

</pre>
<p><br>
<br>
&nbsp;</p>
<p>&nbsp;</p>
<p><br>
&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>

  
  
</article>

  
<section id="comments">
    <!-- 多说分享框 -->
    <div class="ds-share flat" data-thread-key="/2013/07/31/hud1805_题目_Expression_（数组创建二叉树_树的层次遍历/" data-title="hud1805 题目 Expression （数组创建二叉树+树的层次遍历" data-images="https://raw.githubusercontent.com/Hankiya/LoveOnline/master/Rich%20Format%20Vertical.png" data-content="hud1805 题目 Expression （数组创建二叉树+树的层次遍历" data-url="http://hanks.xyz//2013/07/31/hud1805_题目_Expression_（数组创建二叉树_树的层次遍历/">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">

      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
   </div>
    <!-- 多说评论框 start -->
   	<div class="ds-thread" data-thread-key="/2013/07/31/hud1805_题目_Expression_（数组创建二叉树_树的层次遍历/" data-title="hud1805 题目 Expression （数组创建二叉树+树的层次遍历" data-url="http://hanks.xyz//2013/07/31/hud1805_题目_Expression_（数组创建二叉树_树的层次遍历/"></div>
   <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
   <script type="text/javascript">
   var duoshuoQuery = {short_name:"hanks-zyh"};
   	(function() {
   		var ds = document.createElement('script');
   		ds.type = 'text/javascript';ds.async = true;
   		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
   		ds.charset = 'UTF-8';
   		(document.getElementsByTagName('head')[0]
   		 || document.getElementsByTagName('body')[0]).appendChild(ds);
   	})();
   	</script>
   <!-- 多说公共JS代码 end -->
</section>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2015 Hanks<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </br>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    </div>
  </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/jquery.scrollLoading.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>