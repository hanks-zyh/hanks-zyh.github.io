<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>C++ 之 STL | Hanks.xyz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 之 STL">
<meta property="og:url" content="http://hanks.xyz/2013/08/01/C___之_STL/index.html">
<meta property="og:site_name" content="Hanks.xyz">
<meta property="og:description">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/8/0_13207172099IU6.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/8/0_1320717228QV1x.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/9/0_1320801684QU6a.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/9/0_13208010984xk4.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/9/0_1320801684QU6a.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/14/0_1321233460Fi43.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/14/0_1321233476GMB7.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/14/0_1321233489v5C8.gif">
<meta property="og:image" content="http://hi.csdn.net/attachment/201111/14/0_1321233500b76W.gif">
<meta property="og:updated_time" content="2015-12-04T17:20:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 之 STL">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">Hanks.xyz</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about/index.html">关于</a>
        
          <a class="main-nav-link" href="/collections">收集</a>
        
          <a class="main-nav-link" href="/atom.xml">RSS</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanks.xyz"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/hanks-zyh" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about/index.html" class="mobile-nav-link">关于</a>
  
    <a href="/collections" class="mobile-nav-link">收集</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanks.xyz"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="info">
     <div class="content">
       <div>
         <a href="https://github.com/hanks-zyh"><img class="avatar" src="https://avatars2.githubusercontent.com/u/6268322?v=3&s=460" alt="" /></a>
       </div>
       <div class="name">
         <h2 >Hanks</h2>
       </div>
       <p>90后,Android,学习永无止境！</p>
       <div class="account">
         <div class="account-item">
           <a href="http://weibo.com/u/2359002991"><img src="http://hkcoding.sinaapp.com/static/images/ico_05_1.jpg" style="width:40px;height:40px"></a>
         </div>
         <div class="account-item">
              <a href="http://www.zhihu.com/people/yuhan-zhang-36"><img src="http://hkcoding.sinaapp.com/static/images/ico_zhihu.png" style="width:40px;height:40px"></a>
         </div>
         <div class="account-item">
           <a href="http://hanks.xyz/atom.xml"> <img src="http://hkcoding.sinaapp.com/static/images/ico_04_1.jpg" style="width:40px;height:40px"></a>
         </div>
       </div>
     </div>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">最新发布</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/14/framework-application/">Framework分析-Application的onCreate</a>
          </li>
        
          <li>
            <a href="/2016/01/11/react-native-23333/">React-Native 鬼畜表情包app</a>
          </li>
        
          <li>
            <a href="/2016/01/05/android-myhotfix/">Android 动手实现热修复</a>
          </li>
        
          <li>
            <a href="/2016/01/03/android-hotfix/">Android 热修复总结</a>
          </li>
        
          <li>
            <a href="/2015/12/31/2015/">2015回顾@hanks</a>
          </li>
        
          <li>
            <a href="/2015/12/30/snowfall/">Android 下雪动画</a>
          </li>
        
          <li>
            <a href="/2015/12/30/react-zhihu/">React-Native 知乎日报首页</a>
          </li>
        
          <li>
            <a href="/2015/12/29/react-userinfo/">React-Native 练习用户信息界面</a>
          </li>
        
          <li>
            <a href="/2015/12/29/react-viewpager/">React-Native 实现Android中的ViewPager</a>
          </li>
        
          <li>
            <a href="/2015/12/24/react-navigator/">React-Native 的Navigator控制界面跳转</a>
          </li>
        
          <li>
            <a href="/2015/12/23/react-network/">React-Native 网络请求</a>
          </li>
        
          <li>
            <a href="/2015/12/22/react-components/">React-Native 组件练习-购物app侧滑菜单</a>
          </li>
        
          <li>
            <a href="/2015/12/21/react-flexbox/">React-Native中的布局</a>
          </li>
        
          <li>
            <a href="/2015/12/18/atom-nuclide/">Atom安装Nuclide</a>
          </li>
        
          <li>
            <a href="/2015/12/18/react-native-UIExplorer/">运行React-Native例子UIExplorer</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/">Android</a> <a href="/tags/Atom/">Atom</a> <a href="/tags/Framework/">Framework</a> <a href="/tags/Java/">Java</a> <a href="/tags/OS-X/">OS X</a> <a href="/tags/React-Native/">React-Native</a> <a href="/tags/Refactoring/">Refactoring</a> <a href="/tags/Rx/">Rx</a> <a href="/tags/RxJava/">RxJava</a> <a href="/tags/Rxandroid/">Rxandroid</a> <a href="/tags/Rxjava/">Rxjava</a> <a href="/tags/Ubuntu/">Ubuntu</a> <a href="/tags/mac-os/">mac os</a> <a href="/tags/virtualBox/">virtualBox</a> <a href="/tags/必备知识/">必备知识</a> <a href="/tags/热修复/">热修复</a>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <div class="widget">
     <iframe width="100%" height="200" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=0&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=1&uid=2359002991&verifier=05864e99&colors=4ABC88,ffffff,2C3E50,4ABC88,ecfbfd&dpc=1"></iframe>
    </div>
  </div>


  
    
  <div class="widget-wrap mdl-shadow--2dp">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/hanks-zyh">hanks-zyh</a>
          </li>
        
          <li>
            <a href="http://kiya.space">kiya-z</a>
          </li>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>


  
</aside>
        
        <section id="main" class="mdl-shadow--2dp"><article id="post-C___之_STL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/08/01/C___之_STL/" class="article-date">
  <time datetime="2013-08-01T12:19:00.000Z" itemprop="datePublished">2013-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++ 之 STL
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
<h3><span class="link_title"></span>
<div id="body">
<div id="main">
<div class="main">
<div id="article_details" class="details"><span class="ico ico_type_Original"></span>
<h1 class="article_title"><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811">STL系列之一 deque双向队列
</a></span></h1>
<div id="article_content" class="article_content">
<p><span style="font-size:18px">deque双向队列是一种双向开口的连续线性空间，可以高效的在头尾两端插入和删除元素，deque在接口上和vector非常相&#20284;，下面列出deque的常用成员函数：</span></p>
<p align="center"></p>
<div align="left">&nbsp;</div>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><span style="font-size:18px">deque的实现比较复杂，内部会维护一个map（注意！不是STL中的map容器）即一小块连续的空间，该空间中每个元素都是指针，指向另一段（较大的）区域，这个区域称为缓冲区，缓冲区用来保存deque中的数据。因此deque在随机访问和遍历数据会比vector慢。具体的deque实现可以参考《STL源码剖析》，当然此书中使用的SGI STL与VS2008所使用的PJ STL的实现方法还是有区别的。下面给出了deque的结构图：</span></p>
<p><span style="font-size:18px">&nbsp;<img alt="" src="http://hi.csdn.net/attachment/201111/8/0_13207172099IU6.gif"></span></p>
<p><span style="font-size:18px">由于篇幅问题，deque的实现细节就不再深入了，下面给出deque的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6946811#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6946811#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6946811#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6946811#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//双向队列&nbsp;deque </span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="comment">//by&nbsp;MoreWindows&nbsp;http://blog.csdn.net/morewindows
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;deque&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;deque&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;ideq(20);&nbsp;</span><span class="comment">//Create&nbsp;a&nbsp;deque&nbsp;ideq&nbsp;with&nbsp;20&nbsp;elements&nbsp;of&nbsp;default&nbsp;value&nbsp;0
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;deque&lt;</span><span class="datatypes">int</span><span>&gt;::iterator&nbsp;pos;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//使用assign()赋&#20540;&nbsp;&nbsp;assign在计算机中就是赋&#20540;的意思
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ideq[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//输出deque </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;输出deque中数据:\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;20;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;ideq[i]);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//在头尾加入新数据 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n在头尾加入新数据...\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.push_back(100);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.push_front(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//输出deque </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n输出deque中数据:\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(pos&nbsp;=&nbsp;ideq.begin();&nbsp;pos&nbsp;!=&nbsp;ideq.end();&nbsp;pos&#43;&#43;)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//查找 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;FINDNUMBER&nbsp;=&nbsp;19;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n查找%d\n&quot;</span><span>,&nbsp;FINDNUMBER);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;=&nbsp;find(ideq.begin(),&nbsp;ideq.end(),&nbsp;FINDNUMBER);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(pos&nbsp;!=&nbsp;ideq.end())&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;find&nbsp;%d&nbsp;success\n&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;find&nbsp;failed\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//在头尾删除数据 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n在头尾删除数据...\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.pop_back();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ideq.pop_front();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//输出deque </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;\n输出deque中数据:\n&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(pos&nbsp;=&nbsp;ideq.begin();&nbsp;pos&nbsp;!=&nbsp;ideq.end();&nbsp;pos&#43;&#43;)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//双向队列 deque
//by MoreWindows http://blog.csdn.net/morewindows
#include &lt;deque&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int main()
{
	deque&lt;int&gt; ideq(20); //Create a deque ideq with 20 elements of default value 0
	deque&lt;int&gt;::iterator pos;
	int i;

	//使用assign()赋值  assign在计算机中就是赋值的意思
	for (i = 0; i &lt; 20; ++i)
		ideq[i] = i;
	
	//输出deque
	printf(&quot;输出deque中数据:\n&quot;);
	for (i = 0; i &lt; 20; ++i)
		printf(&quot;%d &quot;, ideq[i]);
	putchar('\n');

	//在头尾加入新数据
	printf(&quot;\n在头尾加入新数据...\n&quot;);
	ideq.push_back(100);
	ideq.push_front(i);

	//输出deque
	printf(&quot;\n输出deque中数据:\n&quot;);
	for (pos = ideq.begin(); pos != ideq.end(); pos++)
		printf(&quot;%d &quot;, *pos);
	putchar('\n');

	//查找
	const int FINDNUMBER = 19;
	printf(&quot;\n查找%d\n&quot;, FINDNUMBER);
	pos = find(ideq.begin(), ideq.end(), FINDNUMBER);
	if (pos != ideq.end())
		printf(&quot;find %d success\n&quot;, *pos);
	else
		printf(&quot;find failed\n&quot;);

	//在头尾删除数据
	printf(&quot;\n在头尾删除数据...\n&quot;);
	ideq.pop_back();
	ideq.pop_front();

	//输出deque
	printf(&quot;\n输出deque中数据:\n&quot;);
	for (pos = ideq.begin(); pos != ideq.end(); pos++)
		printf(&quot;%d &quot;, *pos);
	putchar('\n');
	return 0;
}</pre>
<p><span style="font-size:18px">运行结果如下：</span></p>
<p><img alt="" src="http://hi.csdn.net/attachment/201111/8/0_1320717228QV1x.gif"></p>
<p><span style="font-size:18px">另外要注意一点。对于deque和vector来说，尽量少用erase(pos)和erase(beg,end)。因为这在中间删除数据后会导致后面的数据向前移动，从而使效率低下。</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811">http://blog.csdn.net/morewindows/article/details/6946811</a></span></p>
</div>
</div>
</div>
</div>
</div>
</h3>
<h3><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917">STL系列之三 queue 单向队列
</a></span></h3>
<p class="article_content"><span style="font-size:18px">queue单向队列与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>有点类&#20284;，一个是在同一端存取数据，另一个是在一端存入数据，另一端取出数据。单向队列中的数据是先进先出（First In First Out,FIFO）。在STL中，单向队列也是以别的容器作为底部结构，再将接口改变，使之符合单向队列的特性就可以了。因此实现也是非常方便的。下面就给出单向队列的函数列表和VS2008中单向队列的源代码。单向队列一共6个常用函数（<span style="color:#ff0000">front()、back()、push()、pop()、empty()、size()</span>），与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>的常用函数较为相&#20284;。</span></p>
<p class="article_content" align="center"><span style="font-size:18px"><img alt="" src="http://hi.csdn.net/attachment/201111/9/0_1320801684QU6a.gif"></span>
</p>
<div class="article_content" align="left">
<div id="body">
<div id="main">
<div class="main">
<div id="article_details" class="details">
<div class="article_title"><span class="ico ico_type_Original"></span>
<h3><span class="link_title">&nbsp;&nbsp;&nbsp;&nbsp; <a target="_blank" href=""><span style="color:blue"></span></a></span>
<div id="article_details" class="details"><span class="ico ico_type_Original"></span>
<h1 class="article_title"><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">STL系列之二 stack栈
</a></span></h1>
<div id="article_content" class="article_content">
<p align="left"><span style="font-size:18px">栈（statck）这种数据结构在计算机中是相当出名的。栈中的数据是先进后出的（First In Last Out, FILO）。栈只有一个出口，允许新增元素（只能在栈顶上增加）、移出元素（只能移出栈顶元素）、取得栈顶元素等操作。在STL中，栈是以别的容器作为底部结构，再将接口改变，使之符合栈的特性就可以了。因此实现非常的方便。下面就给出栈的函数列表和VS2008中栈的源代码，在STL中栈一共就5个常用操作函数（<span style="color:#ff0000">top()、push()、pop()、
 size()、empty()&nbsp;</span>），很好记的。</span></p>
<p align="center"><img alt="" src="http://hi.csdn.net/attachment/201111/9/0_13208010984xk4.gif" width="454" height="380">
</p>
<div align="left">&nbsp;</div>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p align="left"><strong><span style="font-size:18px">VS2008中栈的源代码</span></strong></p>
<p><span style="font-size:18px">友情提示：初次阅读时请注意其实现思想，不要在细节上浪费过多的时间。</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950881#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950881#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950881#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950881#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//VS2008中&nbsp;stack的定义&nbsp;MoreWindows整理(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="keyword">template</span><span>&lt;</span><span class="keyword">class</span><span>&nbsp;_Ty,&nbsp;</span><span class="keyword">class</span><span>&nbsp;_Container&nbsp;=&nbsp;deque&lt;_Ty&gt;&nbsp;&gt;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;stack&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;LIFO&nbsp;queue&nbsp;implemented&nbsp;with&nbsp;a&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;_Container&nbsp;container_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::value_type&nbsp;value_type;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::size_type&nbsp;size_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::reference&nbsp;reference;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::const_reference&nbsp;const_reference;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;stack()&nbsp;:&nbsp;c()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;with&nbsp;empty&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">explicit</span><span>&nbsp;stack(</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Cont)&nbsp;:&nbsp;c(_Cont)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;by&nbsp;copying&nbsp;specified&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;empty()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;test&nbsp;if&nbsp;stack&nbsp;is&nbsp;empty
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.empty());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;size_type&nbsp;size()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;test&nbsp;length&nbsp;of&nbsp;stack </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.size());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;top()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;mutable&nbsp;stack
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;const_reference&nbsp;top()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;nonmutable&nbsp;stack
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;push(</span><span class="keyword">const</span><span>&nbsp;value_type&amp;&nbsp;_Val)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;insert&nbsp;element&nbsp;at&nbsp;end
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.push_back(_Val);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;pop()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;erase&nbsp;last&nbsp;element </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.pop_back();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Get_container()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;get&nbsp;reference&nbsp;to&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">protected</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;_Container&nbsp;c;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;the&nbsp;underlying&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>};&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//VS2008中 stack的定义 MoreWindows整理(http://blog.csdn.net/MoreWindows)
template&lt;class _Ty, class _Container = deque&lt;_Ty&gt; &gt;
class stack
{	// LIFO queue implemented with a container
public:
	typedef _Container container_type;
	typedef typename _Container::value_type value_type;
	typedef typename _Container::size_type size_type;
	typedef typename _Container::reference reference;
	typedef typename _Container::const_reference const_reference;

	stack() : c()
	{	// construct with empty container
	}

	explicit stack(const _Container&amp; _Cont) : c(_Cont)
	{	// construct by copying specified container
	}

	bool empty() const
	{	// test if stack is empty
		return (c.empty());
	}

	size_type size() const
	{	// test length of stack
		return (c.size());
	}

	reference top()
	{	// return last element of mutable stack
		return (c.back());
	}

	const_reference top() const
	{	// return last element of nonmutable stack
		return (c.back());
	}

	void push(const value_type&amp; _Val)
	{	// insert element at end
		c.push_back(_Val);
	}

	void pop()
	{	// erase last element
		c.pop_back();
	}

	const _Container&amp; _Get_container() const
	{	// get reference to container
		return (c);
	}

protected:
	_Container c;	// the underlying container
};</pre>
<p align="left"><span style="font-size:18px">可以看出，由于栈只是进一步封装别的数据结构，并提供自己的接口，所以代码非常简洁，如果不指定容器，默认是用deque来作为其底层数据结构的（对deque不是很了解？可以参阅</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811"><span style="font-size:18px">《STL系列之一
 deque双向队列》</span></a><span style="font-size:18px">）。下面给出栈的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950881#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950881#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950881#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950881#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//栈&nbsp;stack支持&nbsp;empty()&nbsp;size()&nbsp;top()&nbsp;push()&nbsp;pop()
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="comment">//&nbsp;by&nbsp;MoreWindows(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;stack&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;list&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//可以使用list或vector作为栈的容器，默认是使用deque的。 </span>
<span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;stack&lt;</span><span class="datatypes">int</span><span>,&nbsp;list&lt;</span><span class="datatypes">int</span><span>&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;stack&lt;</span><span class="datatypes">int</span><span>,&nbsp;vector&lt;</span><span class="datatypes">int</span><span>&gt;&gt;&nbsp;&nbsp;&nbsp;b;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//压入数据 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.push(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.push(i);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//栈的大小 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;a.size(),&nbsp;b.size());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//取栈项数据并将数据弹出栈 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!a.empty())&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;a.top());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.pop();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!b.empty())&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;b.top());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.pop();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//栈 stack支持 empty() size() top() push() pop()
// by MoreWindows(http://blog.csdn.net/MoreWindows)
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;cstdio&gt;
using namespace std;
int main()
{
	//可以使用list或vector作为栈的容器，默认是使用deque的。
	stack&lt;int, list&lt;int&gt;&gt;      a;
	stack&lt;int, vector&lt;int&gt;&gt;   b;
	int i;
	
	//压入数据
	for (i = 0; i &lt; 10; i++)
	{
		a.push(i);
		b.push(i);
	}

	//栈的大小
	printf(&quot;%d %d\n&quot;, a.size(), b.size());

	//取栈项数据并将数据弹出栈
	while (!a.empty())
	{
		printf(&quot;%d &quot;, a.top());
		a.pop();
	}
	putchar('\n');

	while (!b.empty())
	{
		printf(&quot;%d &quot;, b.top());
		b.pop();
	}
	putchar('\n');
	return 0;
}</pre>
<p align="left">&nbsp;</p>
<p><span style="font-size:16px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">http://blog.csdn.net/morewindows/article/details/6950881</a></span></p>
</div>
</div>
</h3>
<h3><span class="link_title"></span>&nbsp;</h3>
<h3><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917">STL系列之三 queue 单向队列
</a></span></h3>
</div>
<div class="article_manage"><span class="link_categories">分类： <a target="_blank" href="http://blog.csdn.net/MoreWindows/article/category/923923">
STL 他山之石</a> </span><span class="link_postdate">2011-11-09 09:20</span> <span class="link_view" title="阅读次数">
7902人阅读</span> <span class="link_comments" title="评论次数"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917#comments">评论</a>(10)</span>
<span class="link_collect"><a target="_blank" title="收藏" href="">收藏</a></span> <span class="link_report">
<a target="_blank" title="举报" href="http://blog.csdn.net/morewindows/article/details/6950917#report">举报</a></span>
</div>
<div class="tag2box"><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=reference">reference</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">数据结构</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=class">class</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=insert">insert</a><a target="_blank" href="http://blog.csdn.net/tag/details.html?tag=list">list</a></div>
<div id="article_content" class="article_content">
<p><span style="font-size:18px">queue单向队列与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>有点类&#20284;，一个是在同一端存取数据，另一个是在一端存入数据，另一端取出数据。单向队列中的数据是先进先出（First In First Out,FIFO）。在STL中，单向队列也是以别的容器作为底部结构，再将接口改变，使之符合单向队列的特性就可以了。因此实现也是非常方便的。下面就给出单向队列的函数列表和VS2008中单向队列的源代码。单向队列一共6个常用函数（<span style="color:#ff0000">front()、back()、push()、pop()、empty()、size()</span>），与<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950881">栈</a>的常用函数较为相&#20284;。</span></p>
<p align="center"><span style="font-size:18px"><img alt="" src="http://hi.csdn.net/attachment/201111/9/0_1320801684QU6a.gif"></span>
</p>
<div align="left">&nbsp;</div>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p align="left"><strong><span style="font-size:18px">VS2008中queue单向队列的源代码</span></strong></p>
<p align="left"><span style="font-size:18px">友情提示：初次阅读时请注意其实现思想，不要在细节上浪费过多的时间。</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950917#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950917#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950917#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950917#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span>&lt;SPAN&nbsp;style=</span><span class="string">&quot;FONT-SIZE:&nbsp;18px&quot;</span><span>&gt;</span><span class="comment">//VS2008中&nbsp;queue的定义&nbsp;MoreWindows整理(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="keyword">template</span><span>&lt;</span><span class="keyword">class</span><span>&nbsp;_Ty,&nbsp;</span><span class="keyword">class</span><span>&nbsp;_Container&nbsp;=&nbsp;deque&lt;_Ty&gt;&nbsp;&gt;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">class</span><span>&nbsp;queue&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;FIFO&nbsp;queue&nbsp;implemented&nbsp;with&nbsp;a&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">public</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;_Container&nbsp;container_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::value_type&nbsp;value_type;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::size_type&nbsp;size_type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::reference&nbsp;reference;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">typename</span><span>&nbsp;_Container::const_reference&nbsp;const_reference;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;queue()&nbsp;:&nbsp;c()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;with&nbsp;empty&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">explicit</span><span>&nbsp;queue(</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Cont)&nbsp;:&nbsp;c(_Cont)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;construct&nbsp;by&nbsp;copying&nbsp;specified&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">bool</span><span>&nbsp;empty()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;test&nbsp;if&nbsp;queue&nbsp;is&nbsp;empty
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.empty());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;size_type&nbsp;size()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;length&nbsp;of&nbsp;queue </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.size());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;front()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;first&nbsp;element&nbsp;of&nbsp;mutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.front());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;const_reference&nbsp;front()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;first&nbsp;element&nbsp;of&nbsp;nonmutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.front());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;reference&nbsp;back()&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;mutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;const_reference&nbsp;back()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;return&nbsp;last&nbsp;element&nbsp;of&nbsp;nonmutable&nbsp;queue
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c.back());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;push(</span><span class="keyword">const</span><span>&nbsp;value_type&amp;&nbsp;_Val)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;insert&nbsp;element&nbsp;at&nbsp;beginning
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.push_back(_Val);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;pop()&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;erase&nbsp;element&nbsp;at&nbsp;end </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.pop_front();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;_Container&amp;&nbsp;_Get_container()&nbsp;</span><span class="keyword">const</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;get&nbsp;reference&nbsp;to&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(c);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">protected</span><span>:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;_Container&nbsp;c;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;the&nbsp;underlying&nbsp;container
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>};&lt;/SPAN&gt;&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code"><span style="font-size:18px;">//VS2008中 queue的定义 MoreWindows整理(http://blog.csdn.net/MoreWindows)
template&lt;class _Ty, class _Container = deque&lt;_Ty&gt; &gt;
class queue
{	// FIFO queue implemented with a container
public:
	typedef _Container container_type;
	typedef typename _Container::value_type value_type;
	typedef typename _Container::size_type size_type;
	typedef typename _Container::reference reference;
	typedef typename _Container::const_reference const_reference;

	queue() : c()
	{	// construct with empty container
	}

	explicit queue(const _Container&amp; _Cont) : c(_Cont)
	{	// construct by copying specified container
	}

	bool empty() const
	{	// test if queue is empty
		return (c.empty());
	}

	size_type size() const
	{	// return length of queue
		return (c.size());
	}

	reference front()
	{	// return first element of mutable queue
		return (c.front());
	}

	const_reference front() const
	{	// return first element of nonmutable queue
		return (c.front());
	}

	reference back()
	{	// return last element of mutable queue
		return (c.back());
	}

	const_reference back() const
	{	// return last element of nonmutable queue
		return (c.back());
	}

	void push(const value_type&amp; _Val)
	{	// insert element at beginning
		c.push_back(_Val);
	}

	void pop()
	{	// erase element at end
		c.pop_front();
	}

	const _Container&amp; _Get_container() const
	{	// get reference to container
		return (c);
	}

protected:
	_Container c;	// the underlying container
};</span></pre>
<p align="left"><span style="font-size:18px">可以看出，由于queue只是进一步封装别的数据结构，并提供自己的接口，所以代码非常简洁，如果不指定容器，默认是用deque来作为其底层数据结构的（对deque不是很了解？可以参阅</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6946811"><span style="font-size:18px">《STL系列之一deque双向队列》</span></a><span style="font-size:18px">）。下面给出单向队列的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6950917#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6950917#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6950917#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6950917#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//单向队列&nbsp;queue支持&nbsp;empty()&nbsp;size()&nbsp;front()&nbsp;back()&nbsp;push()&nbsp;pop()
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="comment">//By&nbsp;MoreWindows(http://blog.csdn.net/MoreWindows)
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;queue&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;list&gt; </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//可以使用list作为单向队列的容器，默认是使用deque的。
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;queue&lt;</span><span class="datatypes">int</span><span>,&nbsp;list&lt;</span><span class="datatypes">int</span><span>&gt;&gt;&nbsp;a;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;queue&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//压入数据 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;10;&nbsp;i&#43;&#43;)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.push(i);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.push(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//单向队列的大小 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;a.size(),&nbsp;b.size());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//队列头和队列尾 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;a.front(),&nbsp;a.back());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;%d\n&quot;</span><span>,&nbsp;b.front(),&nbsp;b.back());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//取单向队列项数据并将数据移出单向队列 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!a.empty())&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;a.front());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.pop();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(!b.empty())&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;b.front());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.pop();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//单向队列 queue支持 empty() size() front() back() push() pop()
//By MoreWindows(http://blog.csdn.net/MoreWindows)
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;cstdio&gt;
using namespace std;

int main()
{
	//可以使用list作为单向队列的容器，默认是使用deque的。
	queue&lt;int, list&lt;int&gt;&gt; a;
	queue&lt;int&gt;        b;
	int i;

	//压入数据
	for (i = 0; i &lt; 10; i++)
	{
		a.push(i);
		b.push(i);
	}

	//单向队列的大小
	printf(&quot;%d %d\n&quot;, a.size(), b.size());

	//队列头和队列尾
	printf(&quot;%d %d\n&quot;, a.front(), a.back());
	printf(&quot;%d %d\n&quot;, b.front(), b.back());

	//取单向队列项数据并将数据移出单向队列
	while (!a.empty())
	{
		printf(&quot;%d &quot;, a.front());
		a.pop();
	}
	putchar('\n');

	while (!b.empty())
	{
		printf(&quot;%d &quot;, b.front());
		b.pop();
	}
	putchar('\n');
	return 0;
}</pre>
<p align="left">&nbsp;</p>
<p><span style="font-size:16px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6950917">http://blog.csdn.net/morewindows/article/details/6950917</a></span></p>
</div>
</div>
</div>
</div>
</div>
</div>
<p></p>
<p class="article_content"></p>
<p class="article_content"><span class="link_title"></span>&nbsp;</p>
<p class="article_content"><span class="link_title"></span>&nbsp;</p>
<p class="article_content"><span class="link_title"></span>&nbsp;</p>
<h1 class="article_content"><span class="link_title"><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6967409">STL系列之四 heap 堆
</a></span></h1>
<div id="body">
<div id="main">
<div class="main">
<div id="article_details" class="details">
<div id="article_content" class="article_content">
<p align="left"><span style="font-size:18px">下面再介绍STL中与堆相关的4个函数——建立堆make_heap()，在堆中添加数据push_heap()，在堆中删除数据pop_heap()和堆排序sort_heap()：</span></p>
<p align="left"><span style="font-size:18px">头文件 #include &lt;algorithm&gt;</span></p>
<p align="left"><span style="font-size:18px">下面的_First与_Last为可以随机访问的迭代器（指针），_Comp为比较函数（仿函数），其规则——如果函数的第一个参数小于第二个参数应返回true，否则返回false。</span></p>
<p align="left"><strong><span style="font-size:18px">建立堆</span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">make_heap(_First, _Last, _Comp)</span></p>
<p align="left"><span style="font-size:18px">默认是建立最大堆的。对int类型，可以在第三个参数传入greater&lt;int&gt;()得到最小堆。</span></p>
<p align="left"><strong><span style="font-size:18px">&nbsp;</span></strong></p>
<p align="left"><strong><span style="font-size:18px">在堆中添加数据</span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">push_heap (_First, _Last)</span></p>
<p align="left"><span style="font-size:18px">要先在容器中加入数据，再调用push_heap ()</span></p>
<p align="left"><span style="font-size:18px">&nbsp;</span></p>
<p align="left"><strong><span style="font-size:18px">在堆中删除数据 </span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">pop_heap(_First, _Last)</span></p>
<p align="left"><span style="font-size:18px">要先调用pop_heap()再在容器中删除数据</span></p>
<p align="left"><strong><span style="font-size:18px">&nbsp;</span></strong></p>
<p align="left"><strong><span style="font-size:18px">堆排序</span></strong></p>
<p align="left"><span style="font-size:18px; color:#ff0000">sort_heap(_First, _Last)
</span></p>
<p align="left"><span style="font-size:18px">排序之后就不再是一个合法的heap了</span></p>
<p align="left"><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">有关堆与堆排序的更详细介绍请参阅——《</span><a target="_blank" title="白话经典算法系列之七 堆与堆排序" href="http://blog.csdn.net/morewindows/article/details/6709644"><span style="font-size:18px">白话经典算法系列之七 堆与堆排序</span></a><span style="font-size:18px">》</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p align="left"><span style="font-size:18px">下面给出STL中heap相关函数的使用范例：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6967409#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6967409#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6967409#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6967409#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//by&nbsp;MoreWindows(&nbsp;http://blog.csdn.net/MoreWindows&nbsp;)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;vector&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;functional&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;PrintfVectorInt(vector&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;&amp;vet)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(vector&lt;</span><span class="datatypes">int</span><span>&gt;::iterator&nbsp;pos&nbsp;=&nbsp;vet.begin();&nbsp;pos&nbsp;!=&nbsp;vet.end();&nbsp;pos&#43;&#43;)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d&nbsp;&quot;</span><span>,&nbsp;*pos);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;putchar(</span><span class="string">'\n'</span><span>);&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;MAXN&nbsp;=&nbsp;20;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;a[MAXN];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MAXN;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;rand()&nbsp;%&nbsp;(MAXN&nbsp;*&nbsp;2);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//动态申请vector&nbsp;并对vector建堆 </span>
<span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;</span><span class="datatypes">int</span><span>&gt;&nbsp;*pvet&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;vector&lt;</span><span class="datatypes">int</span><span>&gt;(40);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;assign(a,&nbsp;a&nbsp;&#43;&nbsp;MAXN);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//建堆 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;make_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//加入新数据&nbsp;先在容器中加入，再调用push_heap()
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;push_back(25);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;push_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//删除数据&nbsp;&nbsp;要先调用pop_heap()，再在容器中删除 </span>
<span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pop_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;pop_back();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pop_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pvet-&gt;pop_back();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//堆排序 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;sort_heap(pvet-&gt;begin(),&nbsp;pvet-&gt;end());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;PrintfVectorInt(*pvet);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">delete</span><span>&nbsp;pvet;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">//by MoreWindows( http://blog.csdn.net/MoreWindows )
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
using namespace std;
void PrintfVectorInt(vector&lt;int&gt; &amp;vet)
{
	for (vector&lt;int&gt;::iterator pos = vet.begin(); pos != vet.end(); pos++)
		printf(&quot;%d &quot;, *pos);
	putchar('\n');
}
int main()
{
	const int MAXN = 20;
	int a[MAXN];
	int i;
	for (i = 0; i &lt; MAXN; ++i)
		a[i] = rand() % (MAXN * 2);

	//动态申请vector 并对vector建堆
	vector&lt;int&gt; *pvet = new vector&lt;int&gt;(40);
	pvet-&gt;assign(a, a + MAXN);

	//建堆
	make_heap(pvet-&gt;begin(), pvet-&gt;end());
	PrintfVectorInt(*pvet);

	//加入新数据 先在容器中加入，再调用push_heap()
	pvet-&gt;push_back(25);
	push_heap(pvet-&gt;begin(), pvet-&gt;end());
	PrintfVectorInt(*pvet);

	//删除数据  要先调用pop_heap()，再在容器中删除
	pop_heap(pvet-&gt;begin(), pvet-&gt;end());
	pvet-&gt;pop_back();
	pop_heap(pvet-&gt;begin(), pvet-&gt;end());
	pvet-&gt;pop_back();
	PrintfVectorInt(*pvet);

	//堆排序
	sort_heap(pvet-&gt;begin(), pvet-&gt;end());
	PrintfVectorInt(*pvet);

	delete pvet;
	return 0;
}</pre>
<p align="left"><span style="font-size:18px">掌握其基本用法后，我们用这个堆排序和</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/category/859207"><span style="font-size:18px">《白话经典算法系列》</span></a><span style="font-size:18px">中的</span><a target="_blank" title="白话经典算法系列之七 堆与堆排序" href="http://blog.csdn.net/morewindows/article/details/6709644"><span style="font-size:18px">堆排序</span></a><span style="font-size:18px">、</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6684558"><span style="font-size:18px">快速排序</span></a><span style="font-size:18px">，</span><a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6678165"><span style="font-size:18px">归并排序</span></a><span style="font-size:18px">来进行个性能测试（Win7
 &#43; VS2008 Release下），测试代码如下：</span></p>
<div class="dp-highlighter bg_cpp">
<div class="bar">
<div class="tools"><strong>[cpp]</strong> <a target="_blank" class="ViewSource" title="view plain" href="http://blog.csdn.net/morewindows/article/details/6967409#">
view plain</a><a target="_blank" class="CopyToClipboard" title="copy" href="http://blog.csdn.net/morewindows/article/details/6967409#">copy</a><a target="_blank" class="PrintSource" title="print" href="http://blog.csdn.net/morewindows/article/details/6967409#">print</a><a target="_blank" class="About" title="?" href="http://blog.csdn.net/morewindows/article/details/6967409#">?</a></div>
</div>
<ol class="dp-cpp">
<li class="alt"><span><span class="comment">//&nbsp;by&nbsp;MoreWindows(&nbsp;http://blog.csdn.net/MoreWindows&nbsp;)
</span><span>&nbsp;&nbsp;</span></span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;cstdio&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="preprocessor">#include&nbsp;&lt;algorithm&gt; </span>
<span>&nbsp;&nbsp;</span></li><li><span></span><span class="preprocessor">#include&nbsp;&lt;ctime&gt; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">using</span><span>&nbsp;</span><span class="keyword">namespace</span><span>&nbsp;std;&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//------------------------快速排序----------------------------
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;quick_sort(</span><span class="datatypes">int</span><span>&nbsp;s[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;l,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;r)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(l&nbsp;&lt;&nbsp;r)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;l,&nbsp;j&nbsp;=&nbsp;r,&nbsp;x&nbsp;=&nbsp;s[l];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(i&nbsp;&lt;&nbsp;j)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;j&nbsp;&amp;&amp;&nbsp;s[j]&nbsp;&gt;=&nbsp;x)&nbsp;</span><span class="comment">//&nbsp;从右向左找第一个小于x的数
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(i&nbsp;&lt;&nbsp;j)&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i&#43;&#43;]&nbsp;=&nbsp;s[j];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>(i&nbsp;&lt;&nbsp;j&nbsp;&amp;&amp;&nbsp;s[i]&nbsp;&lt;&nbsp;x)&nbsp;</span><span class="comment">//&nbsp;从左向右找第一个大于等于x的数
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&#43;&#43;;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(i&nbsp;&lt;&nbsp;j)&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[j--]&nbsp;=&nbsp;s[i];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s[i]&nbsp;=&nbsp;x;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quick_sort(s,&nbsp;l,&nbsp;i&nbsp;-&nbsp;1);&nbsp;</span><span class="comment">//&nbsp;递归调用&nbsp;
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quick_sort(s,&nbsp;i&nbsp;&#43;&nbsp;1,&nbsp;r);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="comment">//------------------------归并排序----------------------------
</span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//将有二个有序数列a[first...mid]和a[mid...last]合并。 </span>
<span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;mergearray(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;first,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;mid,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;last,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;temp[])&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;first,&nbsp;j&nbsp;=&nbsp;mid&nbsp;&#43;&nbsp;1;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;m&nbsp;=&nbsp;mid,&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;last;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;k&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(i&nbsp;&lt;=&nbsp;m&nbsp;&amp;&amp;&nbsp;j&nbsp;&lt;=&nbsp;n)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(a[i]&nbsp;&lt;&nbsp;a[j])&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[i&#43;&#43;];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[j&#43;&#43;];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(i&nbsp;&lt;=&nbsp;m)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[i&#43;&#43;];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(j&nbsp;&lt;=&nbsp;n)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp[k&#43;&#43;]&nbsp;=&nbsp;a[j&#43;&#43;];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;k;&nbsp;i&#43;&#43;)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[first&nbsp;&#43;&nbsp;i]&nbsp;=&nbsp;temp[i];&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">void</span><span>&nbsp;mergesort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;first,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;last,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;temp[])&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(first&nbsp;&lt;&nbsp;last)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;mid&nbsp;=&nbsp;(first&nbsp;&#43;&nbsp;last)&nbsp;/&nbsp;2;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergesort(a,&nbsp;first,&nbsp;mid,&nbsp;temp);&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//左边有序
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergesort(a,&nbsp;mid&nbsp;&#43;&nbsp;1,&nbsp;last,&nbsp;temp);&nbsp;</span><span class="comment">//右边有序
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mergearray(a,&nbsp;first,&nbsp;mid,&nbsp;last,&nbsp;temp);&nbsp;</span><span class="comment">//再将二个有序数列合并
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">bool</span><span>&nbsp;MergeSort(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;*p&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;</span><span class="datatypes">int</span><span>[n];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(p&nbsp;==&nbsp;NULL)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mergesort(a,&nbsp;0,&nbsp;n&nbsp;-&nbsp;1,&nbsp;p);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;</span></li><li class="alt"><span>}&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//------------------------堆排序---------------------------
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">inline</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;Swap(</span><span class="datatypes">int</span><span>&nbsp;&amp;a,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;&amp;b)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;c&nbsp;=&nbsp;a;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;b;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;c;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="comment">//建立最小堆 </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="comment">//&nbsp;&nbsp;从i节点开始调整,n为节点总数&nbsp;从0开始计算&nbsp;i节点的子节点为&nbsp;2*i&#43;1,&nbsp;2*i&#43;2
</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;MinHeapFixdown(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;j,&nbsp;temp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;=&nbsp;a[i];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;2&nbsp;*&nbsp;i&nbsp;&#43;&nbsp;1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>&nbsp;(j&nbsp;&lt;&nbsp;n)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(j&nbsp;&#43;&nbsp;1&nbsp;&lt;&nbsp;n&nbsp;&amp;&amp;&nbsp;a[j&nbsp;&#43;&nbsp;1]&nbsp;&lt;&nbsp;a[j])&nbsp;</span><span class="comment">//在左右孩子中找最小的
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&#43;&#43;;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(a[j]&nbsp;&gt;=&nbsp;temp)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">break</span><span>;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;a[j];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//把较小的子结点往上移动,替换它的父结点
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;j;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;2&nbsp;*&nbsp;i&nbsp;&#43;&nbsp;1;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;temp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="comment">//建立最小堆 </span><span>&nbsp;&nbsp;</span></li><li><span></span><span class="keyword">void</span><span>&nbsp;MakeMinHeap(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;n&nbsp;/&nbsp;2&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;0;&nbsp;i--)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinHeapFixdown(a,&nbsp;i,&nbsp;n);&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">void</span><span>&nbsp;MinheapsortTodescendarray(</span><span class="datatypes">int</span><span>&nbsp;a[],&nbsp;</span><span class="datatypes">int</span><span>&nbsp;n)&nbsp;&nbsp;</span></li><li><span>{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;n&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;1;&nbsp;i--)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Swap(a[i],&nbsp;a[0]);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MinHeapFixdown(a,&nbsp;0,&nbsp;i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;MAXN&nbsp;=&nbsp;5000000;&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">int</span><span>&nbsp;a[MAXN];&nbsp;&nbsp;</span></li><li class="alt"><span></span><span class="datatypes">int</span><span>&nbsp;b[MAXN],&nbsp;c[MAXN],&nbsp;d[MAXN];&nbsp;&nbsp;</span></li><li><span></span><span class="datatypes">int</span><span>&nbsp;main()&nbsp;&nbsp;</span></li><li class="alt"><span>{&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;srand(time(NULL));&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MAXN;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]&nbsp;=&nbsp;rand()&nbsp;*&nbsp;rand();&nbsp;</span><span class="comment">//注rand()产生的数在0到0x7FFF之间
</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;MAXN;&nbsp;&#43;&#43;i)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[i]&nbsp;=&nbsp;c[i]&nbsp;=&nbsp;b[i]&nbsp;=&nbsp;a[i];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">clock_t</span><span>&nbsp;ibegin,&nbsp;iend;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;--当前数据量为%d--By&nbsp;MoreWindows(http://blog.csdn.net/MoreWindows)--\n&quot;</span><span>,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//快速排序 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;快速排序:&nbsp;&nbsp;&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;quick_sort(a,&nbsp;0,&nbsp;MAXN&nbsp;-&nbsp;1);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//归并排序 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;归并排序:&nbsp;&nbsp;&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;MergeSort(b,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//堆排序 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;堆排序:&nbsp;&nbsp;&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;MakeMinHeap(c,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;MinheapsortTodescendarray(c,&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//STL中的堆排序 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;STL中的堆排序:&nbsp;&quot;</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ibegin&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;make_heap(d,&nbsp;d&nbsp;&#43;&nbsp;MAXN);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;sort_heap(d,&nbsp;d&nbsp;&#43;&nbsp;MAXN);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;iend&nbsp;=&nbsp;clock();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;%d毫秒\n&quot;</span><span>,&nbsp;iend&nbsp;-&nbsp;ibegin);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;0;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;</span></li></ol>
</div>
<pre style="DISPLAY: none" class="cpp" name="code">// by MoreWindows( http://blog.csdn.net/MoreWindows )
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
using namespace std;
//------------------------快速排序----------------------------
void quick_sort(int s[], int l, int r)
{
	if (l &lt; r)
	{
		int i = l, j = r, x = s[l];
		while (i &lt; j)
		{
			while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数
				j--;  
			if(i &lt; j) 
				s[i++] = s[j];

			while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数
				i++;  
			if(i &lt; j) 
				s[j--] = s[i];
		}
		s[i] = x;
		quick_sort(s, l, i - 1); // 递归调用 
		quick_sort(s, i + 1, r);
	}
}
//------------------------归并排序----------------------------
//将有二个有序数列a[first...mid]和a[mid...last]合并。
void mergearray(int a[], int first, int mid, int last, int temp[])
{
	int i = first, j = mid + 1;
	int m = mid,   n = last;
	int k = 0;

	while (i &lt;= m &amp;&amp; j &lt;= n)
	{
		if (a[i] &lt; a[j])
			temp[k++] = a[i++];
		else
			temp[k++] = a[j++];
	}

	while (i &lt;= m)
		temp[k++] = a[i++];

	while (j &lt;= n)
		temp[k++] = a[j++];

	for (i = 0; i &lt; k; i++)
		a[first + i] = temp[i];
}
void mergesort(int a[], int first, int last, int temp[])
{
	if (first &lt; last)
	{
		int mid = (first + last) / 2;
		mergesort(a, first, mid, temp);    //左边有序
		mergesort(a, mid + 1, last, temp); //右边有序
		mergearray(a, first, mid, last, temp); //再将二个有序数列合并
	}
}
bool MergeSort(int a[], int n)
{
	int *p = new int[n];
	if (p == NULL)
		return false;
	mergesort(a, 0, n - 1, p);
	return true;
}
//------------------------堆排序---------------------------
inline void Swap(int &amp;a, int &amp;b)
{
	int c = a;
	a = b;
	b = c;
}
//建立最小堆
//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2
void MinHeapFixdown(int a[], int i, int n)
{
	int j, temp;

	temp = a[i];
	j = 2 * i + 1;
	while (j &lt; n)
	{
		if (j + 1 &lt; n &amp;&amp; a[j + 1] &lt; a[j]) //在左右孩子中找最小的
			j++;

		if (a[j] &gt;= temp)
			break;

		a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点
		i = j;
		j = 2 * i + 1;
	}
	a[i] = temp;
}
//建立最小堆
void MakeMinHeap(int a[], int n)
{
	for (int i = n / 2 - 1; i &gt;= 0; i--)
		MinHeapFixdown(a, i, n);
}
void MinheapsortTodescendarray(int a[], int n)
{
	for (int i = n - 1; i &gt;= 1; i--)
	{
		Swap(a[i], a[0]);
		MinHeapFixdown(a, 0, i);
	}
}
const int MAXN = 5000000;
int a[MAXN];
int b[MAXN], c[MAXN], d[MAXN];
int main()
{
	int i;
	srand(time(NULL));
	for (i = 0; i &lt; MAXN; ++i)
		a[i] = rand() * rand(); //注rand()产生的数在0到0x7FFF之间

	for (i = 0; i &lt; MAXN; ++i)
		d[i] = c[i] = b[i] = a[i];

    clock_t ibegin, iend;

	printf(&quot;--当前数据量为%d--By MoreWindows(http://blog.csdn.net/MoreWindows)--\n&quot;, MAXN);
	//快速排序
	printf(&quot;快速排序:  &quot;);
	ibegin = clock();
	quick_sort(a, 0, MAXN - 1);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);

	
	//归并排序
	printf(&quot;归并排序:  &quot;);
	ibegin = clock();
	MergeSort(b, MAXN);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);

	//堆排序
	printf(&quot;堆排序:  &quot;);
	ibegin = clock();
	MakeMinHeap(c, MAXN);
	MinheapsortTodescendarray(c, MAXN);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);

	//STL中的堆排序
	printf(&quot;STL中的堆排序: &quot;);	
	ibegin = clock();
	make_heap(d, d + MAXN);
	sort_heap(d, d + MAXN);
	iend = clock();
	printf(&quot;%d毫秒\n&quot;, iend - ibegin);
	return 0;
}</pre>
<p align="left"><span style="font-size:18px">对100000（十万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233460Fi43.gif"></p>
<p align="left"><span style="font-size:18px">对500000（五十万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233476GMB7.gif"></p>
<p align="left"><span style="font-size:18px">对1000000（一百万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233489v5C8.gif"></p>
<p align="left"><span style="font-size:18px">对5000000（五百万）个数据的测试结果：</span></p>
<p align="left"><img alt="" src="http://hi.csdn.net/attachment/201111/14/0_1321233500b76W.gif"></p>
<p><span style="font-size:18px">从中可以看出快速排序的效率确实要比其它同为O(N * logN)的排序算法要高，而STL中堆操作函数的性能与《</span><a target="_blank" title="白话经典算法系列之七 堆与堆排序" href="http://blog.csdn.net/morewindows/article/details/6709644"><span style="font-size:18px">白话经典算法系列之七 堆与堆排序</span></a><span style="font-size:18px">》一文中堆操作函数的性能是相差无几的。</span></p>
<p><span style="font-size:18px">&nbsp;</span></p>
<p><span style="font-size:18px">转载请标明出处，原文地址：<a target="_blank" href="http://blog.csdn.net/morewindows/article/details/6967409">http://blog.csdn.net/morewindows/article/details/6967409</a></span></p>
</div>
</div>
</div>
</div>
</div>

      
    </div>

  
  
</article>

  
<section id="comments">
    <!-- 多说分享框 -->
    <div class="ds-share flat" data-thread-key="/2013/08/01/C___之_STL/" data-title="C++ 之 STL" data-images="https://raw.githubusercontent.com/Hankiya/LoveOnline/master/Rich%20Format%20Vertical.png" data-content="C++ 之 STL" data-url="http://hanks.xyz//2013/08/01/C___之_STL/">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">

      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
   </div>
    <!-- 多说评论框 start -->
   	<div class="ds-thread" data-thread-key="/2013/08/01/C___之_STL/" data-title="C++ 之 STL" data-url="http://hanks.xyz//2013/08/01/C___之_STL/"></div>
   <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
   <script type="text/javascript">
   var duoshuoQuery = {short_name:"hanks-zyh"};
   	(function() {
   		var ds = document.createElement('script');
   		ds.type = 'text/javascript';ds.async = true;
   		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
   		ds.charset = 'UTF-8';
   		(document.getElementsByTagName('head')[0]
   		 || document.getElementsByTagName('body')[0]).appendChild(ds);
   	})();
   	</script>
   <!-- 多说公共JS代码 end -->
</section>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2016 Hanks<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </br>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    </div>
  </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/jquery.scrollLoading.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>
