<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>二叉树 | Hanks&#39; Websit</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <script data-ad-client="ca-pub-8165670162444117" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta name="referrer" content="never">
  <meta name="description" content="#define TRUE 1 #define FALSE 0 &#x2F;&#x2F;---------二叉树链式表示----------- typedef int Status; typedef struct BiTNode { &nbsp;char data; &nbsp;struct BiTNode * lchild, * rchild; }BiTNode,* BiTree; typedef stru">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="https://hanks.pub/2014/02/19/%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="Hanks&#39; Websit">
<meta property="og:description" content="#define TRUE 1 #define FALSE 0 &#x2F;&#x2F;---------二叉树链式表示----------- typedef int Status; typedef struct BiTNode { &nbsp;char data; &nbsp;struct BiTNode * lchild, * rchild; }BiTNode,* BiTree; typedef stru">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2014-02-19T11:17:00.000Z">
<meta property="article:modified_time" content="2024-02-08T01:29:02.196Z">
<meta property="article:author" content="Hanks">
<meta name="twitter:card" content="summary">
  
  
  <link href="https://fonts.googleapis.com/css?family=Fira+Code|Noto+Serif+SC&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8165670162444117"
     crossorigin="anonymous"></script>
  <div id="header-outer" class="outer">
    <a href="/" class="logo"></a>
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="/archives">Archive</a>
      
        <a class="main-nav-link" href="/eye-video">Eye</a>
      
        <a class="main-nav-link" href="/atom.xml">Rss</a>
      
    </nav>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/archives" class="mobile-nav-link">Archive</a>
  
    <a href="/eye-video" class="mobile-nav-link">Eye</a>
  
    <a href="/atom.xml" class="mobile-nav-link">Rss</a>
  
</nav>
      <div class="outer">
        <section id="main"><article id="post-二叉树" class="article article-type-post" itemscope
  itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
    <header class="article-header">
      
      
  
    <h1 class="article-title" itemprop="name">
      二叉树
    </h1>
  

      
    </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
<div id="sina_keyword_ad_area2" class="articalContent  ">
			<p>#define TRUE 1<br />
#define FALSE 0</P>
<p>//---------二叉树链式表示-----------<br />
typedef int Status;<br />
typedef struct BiTNode<br />
{<br />
&nbsp;<wbr>char data;<br />
&nbsp;<wbr>struct BiTNode * lchild, * rchild;<br />
}BiTNode,* BiTree;<br />
typedef struct Stack<br />
{<br />
&nbsp;<wbr>BiTree * top, * base;<br />
}Stack;<br />
#include "iostream"<br />
#include "cstdio"<br />
#include "cstdlib"<br />
//----------栈的函数的定义-----------<br />
void InitStack(Stack &amp;S)<br />
{<br />
&nbsp;<wbr>S.base = S.top&nbsp;<wbr> = (BiTree
*)malloc(sizeof(BiTree) * 100);<br />
}<br />
Status StackEmpty(Stack S)<br />
{<br />
&nbsp;<wbr>if(S.top == S.base) return TRUE;<br />
&nbsp;<wbr>else return FALSE;<br />
}<br />
void Push(Stack &amp;S,BiTree e)<br />
{<br />
&nbsp;<wbr>* S.top ++ = e;<br />
}<br />
void Pop(Stack &amp;S,BiTree &amp;e)<br />
{<br />
&nbsp;<wbr>e = *( --S.top );<br />
}<br />
BiTree GetTop(Stack S)<br />
{<br />
&nbsp;<wbr>return *(S.top-1);<br />
}<br />
//----------二叉树的函数定义----------<br />
void CreateBiTree(BiTree &amp;T)<br />
{//按先序次序输入二叉树中结点的值（一个字符），# 代表空树 ，如：ABC##DE#G##F###<br />
//则前序遍历：ABCDEGF&nbsp;<wbr> 中序遍历：CBEGDFA&nbsp;<wbr>
后序遍历：CGEFDBA<br />
&nbsp;<wbr>char ch = getchar();<br />
&nbsp;<wbr>if(ch == '#') T = NULL;<br />
&nbsp;<wbr>else {<br />
&nbsp;<wbr>&nbsp;<wbr>if(!(T = (BiTNode
*)malloc(sizeof(BiTNode)))) exit(OVERFLOW);<br />
&nbsp;<wbr>&nbsp;<wbr>T-&gt;data =
ch;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>//生成根结点<br />

&nbsp;<wbr>&nbsp;<wbr>CreateBiTree(T-&gt;lchild);&nbsp;<wbr>//构造左子树<br />

&nbsp;<wbr>&nbsp;<wbr>CreateBiTree(T-&gt;rchild);&nbsp;<wbr>//构造右子树<br />

&nbsp;<wbr>}<br />
}//CreateBiTree<br />
void Visit(char c)<br />
{<br />
&nbsp;<wbr>printf("%c",c);<br />
}<br />
void PreOrderTraverse(BiTree T)<br />
{//先序遍历二叉树，递归<br />
&nbsp;<wbr>if(T){<br />
&nbsp;<wbr>&nbsp;<wbr>Visit(T-&gt;data);<br />
&nbsp;<wbr>&nbsp;<wbr>PreOrderTraverse(T-&gt;lchild);<br />

&nbsp;<wbr>&nbsp;<wbr>PreOrderTraverse(T-&gt;rchild);<br />

&nbsp;<wbr>}<br />
}<br />
void PostOrderTraverse(BiTree T)<br />
{//先序遍历二叉树，递归<br />
&nbsp;<wbr>if(T){<br />
&nbsp;<wbr>&nbsp;<wbr>PostOrderTraverse(T-&gt;lchild);<br />

&nbsp;<wbr>&nbsp;<wbr>PostOrderTraverse(T-&gt;rchild);<br />

&nbsp;<wbr>&nbsp;<wbr>Visit(T-&gt;data);<br />
&nbsp;<wbr>}<br />
}<br />
void InOrderTraverse(BiTree T)<br />
{//中序遍历二叉树，非递归<br />
&nbsp;<wbr><br />
&nbsp;<wbr><br />
&nbsp;<wbr>Stack S;InitStack(S);<br />
&nbsp;<wbr>BiTree p = T;<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> while( p ||
!StackEmpty(S)) {<br />
&nbsp;<wbr>&nbsp;<wbr>//printf("\n%%%%%%%%%%%%调试%%%%%%%%%%%%%%%%%%%%\n");<br />

&nbsp;<wbr>&nbsp;<wbr>//PreOrderTraverse(p);<br />
&nbsp;<wbr>&nbsp;<wbr>//PreOrderTraverse(GetTop(S));<br />

&nbsp;<wbr>&nbsp;<wbr>//printf("\n%%%%%%%%%%%%调试%%%%%%%%%%%%%%%%%%%%\n");<br />

&nbsp;<wbr>&nbsp;<wbr>if(p)
{Push(S,p);&nbsp;<wbr>&nbsp;<wbr> p =
p-&gt;lchild;}<br />
&nbsp;<wbr>&nbsp;<wbr>if( p == NULL &amp;&amp;
!StackEmpty(S)) {<br />
&nbsp;<wbr>&nbsp;<wbr>//&nbsp;<wbr>printf("dddd\n");<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>Pop(S,p);//空指针退栈<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>Visit(p-&gt;data);<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>p =
p-&gt;rchild;&nbsp;<wbr><br />
&nbsp;<wbr>&nbsp;<wbr>}//else<br />
&nbsp;<wbr>}//while<br />
}<br />
void CountLeaf (BiTree T,&nbsp;<wbr> int&amp; count){<br />
&nbsp;<wbr>&nbsp;<wbr> if ( T ) {<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
if ((!T-&gt;lchild)&amp;&amp; (!T-&gt;rchild))<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
count++;&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
// 对叶子结点计数<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
CountLeaf( T-&gt;lchild, count);&nbsp;<wbr><br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
CountLeaf( T-&gt;rchild, count);<br />
&nbsp;<wbr>&nbsp;<wbr> } // if<br />
} // CountLeaf<br />
int Depth (BiTree T ){ // 返回二叉树的深度<br />
&nbsp;<wbr>int depthval,depthLeft,depthRight;<br />
&nbsp;<wbr>if ( !T
)&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> depthval =
0;<br />
&nbsp;<wbr>else&nbsp;<wbr> {<br />
&nbsp;<wbr>&nbsp;<wbr>depthLeft = Depth( T-&gt;lchild
);<br />
&nbsp;<wbr>&nbsp;<wbr>depthRight= Depth( T-&gt;rchild
);<br />
&nbsp;<wbr>&nbsp;<wbr>depthval = 1 + ( depthLeft &gt;
depthRight ? depthLeft : depthRight);<br />
&nbsp;<wbr>}&nbsp;<wbr>&nbsp;<wbr><br />
&nbsp;<wbr>return depthval;<br />
}</P>
<p><br />
int main()<br />
{<br />
&nbsp;<wbr>BiTree T;<br />
&nbsp;<wbr>int count = 0;</P>
<p>&nbsp;<wbr>int num,init=0;<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr> int
door=1;//控制是否退出最外层while循环<br />
&nbsp;<wbr>while( door )<br />
&nbsp;<wbr>{&nbsp;<wbr><br />
&nbsp;<wbr>&nbsp;<wbr>printf("-----------------------------------------------------------------\n");<br />

&nbsp;<wbr>&nbsp;<wbr>printf("\n&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
如要对二叉树进行操作，请输入各项前面相应的数字\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
************************************\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|&nbsp;<wbr>1、创建二叉树&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|&nbsp;<wbr>2、先序遍历（递归）&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|&nbsp;<wbr>3、中序遍历（非递归）&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|&nbsp;<wbr>4、后序遍历（递归）&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|&nbsp;<wbr>5、求叶子节点个数&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|&nbsp;<wbr>6、求树的深度&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|&nbsp;<wbr>0、退出&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
|\n");<br />
&nbsp;<wbr>&nbsp;<wbr>printf("&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>
************************************\n");</P>
<p>&nbsp;<wbr>&nbsp;<wbr>printf(" 请输入数字进行操作：");<br />
&nbsp;<wbr>&nbsp;<wbr>scanf("%d",&amp;num);<br />
&nbsp;<wbr>&nbsp;<wbr>if(num==0||num==1||num==2||num==3||num==4||num==5||num==6)<br />

&nbsp;<wbr>&nbsp;<wbr>{<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>printf("\n-----------------------------------------------------------------\n");<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>switch( num
)<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>{<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>case
0:<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>door
= 0;<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>break;<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>case
1:<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>printf("请按先序次序输入二叉树的结点(以A、B、C等代表结点，#
代表空)，如ABC##DE#G##F###\n");<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>getchar();//清屏函数<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>CreateBiTree(T);<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>init=1;<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>break;&nbsp;<wbr>&nbsp;<wbr><br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>case
2:<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>if(init){<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>printf("先序遍历为：");&nbsp;<wbr>
PreOrderTraverse (T);&nbsp;<wbr>
printf("\n");&nbsp;<wbr>break;<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>}<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>else{
printf("请先创建二叉树！\n");&nbsp;<wbr>break;}<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>case
3:<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>if(init){<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>printf("中序遍历为：");&nbsp;<wbr>&nbsp;<wbr>
InOrderTraverse(T);&nbsp;<wbr>&nbsp;<wbr>
printf("\n");&nbsp;<wbr>break;<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>}<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>else{
printf("请先创建二叉树！\n");&nbsp;<wbr>break;}<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>case
4:<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>if(init){<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>printf("后序遍历为：");&nbsp;<wbr>&nbsp;<wbr>
PostOrderTraverse(T);&nbsp;<wbr>
printf("\n");&nbsp;<wbr>break;<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>}<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>else{
printf("请先创建二叉树！\n");&nbsp;<wbr>break;}<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>case
5:<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>if(init){<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>CountLeaf(T,count);&nbsp;<wbr>printf("叶子结点个数为：%d\n",count);&nbsp;<wbr>break;<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>}<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>else{
printf("请先创建二叉树！\n");&nbsp;<wbr>break;}</P>
<p>
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>case
6:<br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>if(init){<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>printf("树的深度为：%d\n",Depth(T));&nbsp;<wbr>break;<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>}<br />

&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>else{
printf("请先创建二叉树！\n");&nbsp;<wbr>break;}<br />
&nbsp;<wbr>&nbsp;<wbr><br />
&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>}//switch<br />

&nbsp;<wbr>&nbsp;<wbr>}//if<br />
&nbsp;<wbr>&nbsp;<wbr>else
{printf("输入不正确请重新输入！\n");continue;}<br />
&nbsp;<wbr>}//while<br />
&nbsp;<wbr>return 0;<br />
}</P>							
		</div>

      
    </div>
</article>

<!-- 上一页 下一页 -->


<nav id="article-nav">
  
    <a href="/2014/02/19/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left"></i><span>上一篇</span>
      <div class="article-nav-title">
        
          二叉平衡树
        
      </div>
    </a>
  
  
    <a href="/2014/02/19/%E5%B7%B2%E7%9F%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E6%B1%82%E2%80%A6/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left"></i><span>下一篇</span>
      <div class="article-nav-title">已知二叉树前、中序遍历，求…</div>
    </a>
  
</nav>



<!-- 相关文章 -->

<!--

-->


</section>
      </div>
      <footer id="footer">
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      
      &copy;2025<a target="_blank" rel="noopener" href="https://github.com/hanks-zyh"> Hanks</a>版权所有
      <br/>
      <a href="https://beian.miit.gov.cn/" target="_blank">豫ICP备2021022347号</a>
	  </div>
  </div>
 <div id="share">
  <a id="totop" title="" style="display: block;">返回顶部</a>
 </div>
</footer>

    </div>
    


<script src="/js/jquery.min.js"></script>


<script src="/js/jquery.scrollLoading.js"></script>





<script src="/js/script.js"></script>


<script src="/js/ads.js"></script>

  </div>
</body>
</html>
