<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>重构 Plaid app - 响应式的MVP模式(一) | Hanks.xyz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Nick Butcher 在 github 上开源了Plaid。这个app不仅很酷,还拥有极致的 UI / UX。如此炫酷的app的代码对开发者来说copy下来阅读一下可谓是最佳实践。于是我也copy下来,决定深入Plaid的代码。像往常一样,你会发现代码的某些部分可以实现或者用另一种方式。因此不只是谈论代码,我决定花一些时间来重构Plaid的部分源代码。我将写3篇文章来分享我关于如何重构Plai">
<meta property="og:type" content="article">
<meta property="og:title" content="重构 Plaid app - 响应式的MVP模式(一)">
<meta property="og:url" content="http://hanks.xyz/2015/12/08/refactoring-plaid-1/index.html">
<meta property="og:site_name" content="Hanks.xyz">
<meta property="og:description" content="Nick Butcher 在 github 上开源了Plaid。这个app不仅很酷,还拥有极致的 UI / UX。如此炫酷的app的代码对开发者来说copy下来阅读一下可谓是最佳实践。于是我也copy下来,决定深入Plaid的代码。像往常一样,你会发现代码的某些部分可以实现或者用另一种方式。因此不只是谈论代码,我决定花一些时间来重构Plaid的部分源代码。我将写3篇文章来分享我关于如何重构Plai">
<meta property="og:image" content="https://dn-coding-net-production-pp.qbox.me/754a0ecf-5545-4c24-9d4a-3f16bf89ed8e.png">
<meta property="og:image" content="http://hannesdorfmann.com/images/plaid/routing1.png">
<meta property="og:image" content="http://hannesdorfmann.com/images/plaid/routing1.png">
<meta property="og:image" content="http://hannesdorfmann.com/images/plaid/routing3.png">
<meta property="og:image" content="http://hannesdorfmann.com/images/plaid/routing4.png">
<meta property="og:image" content="http://hannesdorfmann.com/images/plaid/routing5.png">
<meta property="og:updated_time" content="2015-12-08T10:23:14.458Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重构 Plaid app - 响应式的MVP模式(一)">
<meta name="twitter:description" content="Nick Butcher 在 github 上开源了Plaid。这个app不仅很酷,还拥有极致的 UI / UX。如此炫酷的app的代码对开发者来说copy下来阅读一下可谓是最佳实践。于是我也copy下来,决定深入Plaid的代码。像往常一样,你会发现代码的某些部分可以实现或者用另一种方式。因此不只是谈论代码,我决定花一些时间来重构Plaid的部分源代码。我将写3篇文章来分享我关于如何重构Plai">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">Hanks.xyz</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about/index.html">关于</a>
        
          <a class="main-nav-link" href="/atom.xml">RSS</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanks.xyz"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/hanks-zyh" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about/index.html" class="mobile-nav-link">关于</a>
  
    <a href="/atom.xml" class="mobile-nav-link">RSS</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hanks.xyz"></form>
  </div>
</nav>
      <div class="outer">
        
        <section id="main"><article id="post-refactoring-plaid-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/08/refactoring-plaid-1/" class="article-date">
  <time datetime="2015-12-08T10:17:00.000Z" itemprop="datePublished">2015-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      重构 Plaid app - 响应式的MVP模式(一)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Nick Butcher 在 <a href="https://github.com/nickbutcher/plaid" target="_blank" rel="external">github</a> 上开源了Plaid。这个app不仅很酷,还拥有极致的 UI / UX。如此炫酷的app的代码对开发者来说copy下来阅读一下可谓是最佳实践。于是我也copy下来,决定深入Plaid的代码。像往常一样,你会发现代码的某些部分可以实现或者用另一种方式。因此不只是谈论代码,我决定花一些时间来重构Plaid的部分源代码。我将写3篇文章来分享我关于如何重构Plaid的,这篇文章是第一部分。</p>
<p>前言: 开始我满满的自信以为自己能重构整个app. 然而,事实是我太天真了,我低估了这个应用的复杂度和新特性的数量。在我花了几个小时阅读 Nick Butcher的代码之后, 我发现了一些有些功能仅仅通过使用应用程序很难发现。一句话:我意识到我没有时间把所有的想法付诸行动。因此我的“重构”集中于应用程序的“主页”和“搜索屏幕”。本来想要讨论(理论上)一些事情可以重构,但是由于时间原因没有完成。重构代码可以在<a href="https://github.com/sockeqwe/plaid" target="_blank" rel="external">github上</a>找到</p>
<a id="more"></a>
<blockquote>
<p>原文链接 : <a href="http://hannesdorfmann.com/android/plaid-refactored-1/" target="_blank" rel="external">REFACTORING PLAID APP - A REACTIVE MVP APPROACH (PART 1)</a><br>译者 : <a href="https://github.com/hanks-zyh" target="_blank" rel="external">hanks-zyh</a></p>
</blockquote>
<h2 id="初见">初见</h2><p>整体的用户体验和用户交互都非常赞.看下面这条tweet:</p>
<p> <img src="https://dn-coding-net-production-pp.qbox.me/754a0ecf-5545-4c24-9d4a-3f16bf89ed8e.png" alt="图片"></p>
<p>使用这个app真是在享受. 它的 UI / UX 对每个开发者或者设计师很激励, 然而,在使用过程中我遇到了一些bug:</p>
<ul>
<li><p>同时显示了加载提示和错误提示:</p>
<iframe width="880" height="660" src="https://www.youtube.com/embed/zCwESjEpNdk" frameborder="0" allowfullscreen></iframe>
</li>
<li><p>在筛选面板中你可以从 Dribbble, Designer News 和 Product Hunt 选择你想要显示的来源.但是当取消选择正在加载数据的”源”的时候,你会遇到item还在显示的问题:</p>
<iframe width="880" height="660" src="https://www.youtube.com/embed/nJ3VUjpW0N0" frameborder="0" allowfullscreen></iframe>
</li>
<li><p>而且app没有考虑屏幕旋转.当屏幕旋转界面会被重新创建,重新执行http请求,你可以看到加载提示ute the http calls:</p>
<iframe width="880" height="660" src="https://www.youtube.com/embed/tuIDrtvL0lg" frameborder="0" allowfullscreen></iframe>

</li>
</ul>
<p>通常这样的“问题”是由于<strong>面条式代码</strong> 和不够好的架构。所以让我们来看看显示项目列表的源代码:在 <code>HomeActivity</code> (大约750行代码)处理UI元素的可见性,如<code>RecylcerView</code>或<code>ProgressBar</code>。这个activity也决定何时显示Source-Filters-Drawer(右边侧滑栏)。此外,在它的 <code>onactivityresult()</code>  做了很多事情,包括发布新的post到designers news。而且它使用 <code>DataManager</code>为选定的 filter 加载数据。你看,HomeActivity有很多责任,可能太多了。<code>DataManager</code> 基本上使用 <code>retrofit</code> 和 <code>asynctask</code> 执行http请求来加载数据。这里的最头疼的问题是分页。每当RecyclerView滑动到底部,需要加载更多。<code>DataManager</code> 内部使用<code>HashMap</code>来记录每个源显示的页面数据(后端的endpoint 如 “Dribbble Popular” , “Dribbble Recent” 或者 “Designer News Popular”)。项目中使用<code>FeedAdapter</code>来通过 RecyclerView显示。 和 <code>SearchActivity</code>跟<code>HomeActivity</code>非常相似:它也使用<code>DataManager</code>和<code>FeedAdapter</code>。</p>
<h2 id="架构">架构</h2><p>在我看来在当前实现中架构不清晰。<code>HomeActivity</code>被用来管理许多事情。另一个“问题”是<code>HomeActivity</code>从不同的方法和不同的事件来调用相同的(内部)方法去改变UI状态,如 <code>checkEmptyState()</code> 在<code>HomeActivity</code>的4个不同的地方被调用.</p>
<p>我们将使用 <code>Model-View-Presenter</code> 来重构一下.  passive view 仅仅用来展示, presenter告诉passive view什么时候展示.我热衷于MVP架构. 不时有人问我为什么我建议使用 passive view,而不是控制器或其他MVP派生。好吧,如果你使用MVP没有 passive view,你基本上是把<strong>面条式代码</strong>写成了一半的 presenter 一半的 passive view。</p>
<h2 id="HomeActivity_in_MVP">HomeActivity in MVP</h2><p>我们使用 MVP +  passive view 把职责分成两个类: <code>HomeActivity</code> 和 <code>HomeView</code>,  <code>HomeActivity</code>作为View (passive view ) 实现了<code>HomeView</code>接口:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface HomeView : MvpView &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showLoading</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showContent</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showError</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showLoadingMore</span><span class="params">(showing: <span class="typename">Boolean</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showLoadingMoreError</span><span class="params">(t: <span class="typename">Throwable</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addOlderItems</span><span class="params">(items: <span class="typename">List&lt;PlaidItem&gt;</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>HomeActivity</code> 负责管理UI(是否可见,位置,动画),但是由 presenter告诉什么时候去执行,所以View的状态由<code>HomePresenter</code> 管理, <code>HomePresenter</code> 的代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePresenter</span></span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> itemsLoader</span>: ItemsLoader<span class="type">&lt;List&lt;PlaidItem&gt;</span>&gt;) : RxPresenter<span class="type">&lt;HomeView, List&lt;PlaidItem&gt;</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadItems</span><span class="params">()</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        view?.showLoading()</span><br><span class="line">        subscribe(</span><br><span class="line">                itemsLoader.firstPage(),</span><br><span class="line">                &#123; <span class="comment">// onError</span></span><br><span class="line">                    view?.showError()</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123; <span class="comment">// onNext</span></span><br><span class="line">                    view?.addOlderItems(it)</span><br><span class="line">                    view?.showContent()</span><br><span class="line">                &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadMore</span><span class="params">()</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        view?.showLoadingMore(<span class="literal">true</span>)</span><br><span class="line">        subscribe(</span><br><span class="line">                itemsLoader.olderPages(),</span><br><span class="line">                &#123; <span class="comment">// onError</span></span><br><span class="line">                    view?.showLoadingMoreError(it)</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123; <span class="comment">// onNext</span></span><br><span class="line">                    view.addOlderItems(it)</span><br><span class="line">                    view.showLoadingMore(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能你注意到了,我使用的是kotlin语言,主要是因为我喜欢这个语言并且有幸看到kotlin的发展,由于kotlin的互操作行(与java相互调用)使得我很容易的重用 Nick Butcher的 java 代码(主要是UI 或者View 方面的东西).</p>
<p>为了实现 MVP, 我们使用了Mosby 库,这是一个MVP 库,当旋转屏幕的时候允许我们保持 presenters, 这样就不会在旋转屏幕时重新启动界面,加载提示,进行请求了, Mosby 也可以在旋转屏幕的时候保持view的状态.</p>
<p>此外我决定在Model层使用 <code>RxJava</code>(在 presenters中可以使用 <code>subscribe()</code> 方法). <code>ItemsLoader</code> 是我重构的 reactive版本的 DataManager. 我来花一分钟解释一下.</p>
<h2 id="SearchActivity_in_MVP">SearchActivity in MVP</h2><p>就像前面所说的, <code>SearchActivity</code> 和 <code>HomeActivity</code> 很像, 他展示了一个列表(grid),并且会在  <code>RecyclerView</code>滑动到底部的时候加载更多items, 所以 <code>SearchActivity</code> 应用MVP跟前面一样:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface SearchView extends MvpView &#123;</span><br><span class="line">  void showLoading();</span><br><span class="line">  void showContent();</span><br><span class="line">  void showError(Throwable t);</span><br><span class="line">  void showLoadingMore(boolean showing);</span><br><span class="line">  void showLoadingMoreError(Throwable t);</span><br><span class="line">  void addOlderItems(List<span class="type">&lt;PlaidItem&gt;</span> items);</span><br><span class="line">  void showSearchNotStarted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchPresenter</span></span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> itemsLoaderFactory</span>: SearchItemsLoaderFactory) : RxPresenter<span class="type">&lt;SearchView, List&lt;PlaidItem&gt;</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> itemsLoader</span>: ItemsLoader<span class="type">&lt;List&lt;PlaidItem&gt;</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">search</span><span class="params">(query: <span class="typename">String</span>)</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create items loader for the given query string</span></span><br><span class="line">        itemsLoader = itemsLoaderFactory.create(query)</span><br><span class="line"></span><br><span class="line">        view?.showLoading()</span><br><span class="line"></span><br><span class="line">        subscribe(itemsLoader!!.firstPage(), &#123; <span class="comment">// Error handling</span></span><br><span class="line">            view?.showError(it)</span><br><span class="line">        &#125;, &#123; <span class="comment">// onNext</span></span><br><span class="line">            view?.addOlderItems(it)</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            view?.showContent()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">searchMore</span><span class="params">(query: <span class="typename">String</span>)</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        view?.showLoadingMore(<span class="literal">true</span>)</span><br><span class="line">        subscribe(itemsLoader!!.olderPages(), &#123; <span class="comment">// Error handling</span></span><br><span class="line">            view?.showLoadingMore(<span class="literal">false</span>)</span><br><span class="line">            view?.showLoadingMoreError(it)</span><br><span class="line">        &#125;, &#123; <span class="comment">// onNext</span></span><br><span class="line">            view?.addOlderItems(it)</span><br><span class="line">        &#125;, &#123; <span class="comment">// onComplete</span></span><br><span class="line">            view?.showLoadingMore(<span class="literal">false</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clearSearch</span><span class="params">()</span> &#123;</span></span><br><span class="line">        <span class="comment">// Unsubscribe any previous search subscriptions</span></span><br><span class="line">        unsubscribe()</span><br><span class="line"></span><br><span class="line">        view.showSearchNotStarted()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟 <code>HomePresenter</code> 唯一不同的是,  <code>SearchPresenter</code> 通过传入一个<code>SearchItemsLoaderFactory</code> 作为构造方法的参数,为每次搜索查询创建了一个 <code>ItemsLoader</code>. 我们来简单看一下它是怎么工作的.</p>
<h2 id="ItemsLoader_和_Pagination">ItemsLoader 和 Pagination</h2><p>目前我们完成了 <code>View</code> 和 <code>Presenter</code>, 现在讨论一下如何重构 “Model”</p>
<p>在我们开始之前: 了解一下 <code>PlaidItem</code>类 ( 包含title和 image url). 这个类是单个item的基类<br><code>Shot</code> extends <code>PlaidItem</code> :代表从Dribbble加载的item<br><code>Story</code> extends <code>PlaidItem</code>: 代表从Designer News加载的item<br><code>Post</code> extends <code>PlaidItem</code>: 代表从 Product Hunt 加载的item<br>现在我们讨论一下使用<code>RxJava</code> 来高效的重写一下 <code>DataManager</code>, 我使用RxJava是因为它简直酷毙了, 你将会体会到它的强大(特别是这个系列的第二篇)并且从中受益.</p>
<p>加载项的困难的部分是,我们从不同的后端支持分页和加载items。让我们从“自下而上”构建ItemsLoader。在“底部”我们将找到一执行 http 的 Retrofit 接口。现在你可以搜索Dribbble和DesignerNews。分页的问题: Dribbble 通过调用 loadItems(0,100)来加载100个items, 调用loadItems(100、200)加载下一个页面的100个, 而DesignerNews是每次page加1,通过调用 loadItems(0,1)来加载第一个页面, 调用loadItems(1,2)加载下一个页面。我们需要一个通用的API。我们可以使用kotlin的高级函数(传递函数参数或者匿名函数)。所以我们需要的是一个组件,这个组件包含这样的一个函数,这个函数执行http请求并返回一个Observable。所以我们需要这样的:  <code>backendMethodToCall:(Int,Int)-&gt; Observable&lt;T&gt;</code>, 第一个参数代表page,第二个代表limit(每页加载多少条), T 泛型代表返回结果的类型(事实上我们总是让返回&lt; PlaidItem&gt;)。<br> 我们把这个组件叫做 <code>RouteCaller</code>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteCaller</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> startPage</span>: <span class="typename">Int</span> = <span class="number">0</span>,</span><br><span class="line">                     <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> itemsPerPage</span>: <span class="typename">Int</span>,</span><br><span class="line">                     <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> backendMethodToCall</span>: (<span class="typename">Int</span>, <span class="typename">Int</span>) -&gt; Observable<span class="type">&lt;T&gt;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Offset for loading more</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> olderPageOffset</span> = AtomicInteger(startPage)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A queue that is used to retry "older"</span><br><span class="line">     * pages if they have failed before continue with even more older</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> olderFailedButRetryLater</span>: Queue<span class="type">&lt;Int&gt;</span> = LinkedBlockingQueue<span class="type">&lt;Int&gt;</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Get an observable to load older data from backend.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getOlderWithRetry</span><span class="params">()</span>: Observable<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> pageOffset</span> = <span class="keyword">if</span> (</span><br><span class="line">        olderFailedButRetryLater.isEmpty()) &#123;</span><br><span class="line">            olderPageOffset.addAndGet(itemsPerPage)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            olderFailedButRetryLater.poll()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backendMethodToCall(pageOffset, itemsPerPage)</span><br><span class="line">                .doOnError &#123;</span><br><span class="line">                    olderFailedButRetryLater.add(pageOffset)</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Get an observable to load the newest data from backend.</span><br><span class="line">     * This method should be invoked on pull to refresh</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getFirst</span><span class="params">()</span>: Observable<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">        <span class="keyword">return</span> backendMethodToCall(startPage, itemsPerPage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RouteCaller</code> 接受一个<code>method(Int, Int) -&gt; Observable&lt;T&gt;</code> 作为构造函数的参数, 根据传入不同的参数执行不同的动作:</p>
<ul>
<li>getFirst() 加载第一页</li>
<li>getOlderWithRetry(): 加载老的数据.<br>我们使用 olderFailedButRetryLater 字段来记录当前页码, 当执行加载更多的时候加1, 此外当加载下一页数据失败后,我们在 <code>.doOnError()</code> 方法中进行重试<br>所以 <code>RouteCaller</code>的职责就是传输参数,执行实际的后端请求,于是有下面的结构:</li>
</ul>
<p><img src="http://hannesdorfmann.com/images/plaid/routing1.png" alt="RouteCaller"></p>
<p>我们有两个接口 <code>DesignerNewsService</code> 和 <code>DribbleService</code> 去执行搜索, 这意味着我们需要两个 <code>RouteCaller</code>:</p>
<p><img src="http://hannesdorfmann.com/images/plaid/routing1.png" alt="RouteCaller"></p>
<p>下一个问题是:如何实例化一个 <code>RouteCalls</code>? 我们为每一个后端服务各定义一个 <code>RouteCallerFactory</code><br>它提供一个方法 <code>getAllBackendCallers()</code> 来得到一个 Observable的 List<routecaller> .</routecaller></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface RouteCallerFactory<span class="type">&lt;T&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Get all available backend route callers</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllBackendCallers</span><span class="params">()</span>: Observable<span class="type">&lt;List&lt;RouteCaller&lt;T&gt;</span>&gt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在DesignerNewsSearchCallerFactory DesignerNewsSearchCallerFactory,和 DribbbleSearchCallerFactory执行搜索, 简单看一下<code>DesignerNewsSearchCallerFactory</code>的代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesignerNewsSearchCallerFactory</span></span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> searchQuery</span>: String, <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> backend</span>: DesignerNewsService) : RouteCallerFactory<span class="type">&lt;List&lt;PlaidItem&gt;</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> extractPlaidItemsFromStory</span> = <span class="function"><span class="title">fun</span><span class="params">(story: <span class="typename">StoriesResponse</span>)</span>: List<span class="type">&lt;PlaidItem&gt;</span> &#123;</span></span><br><span class="line">        <span class="keyword">return</span> story.stories</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The method to execute from RouteCaller</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> searchCall</span> = <span class="function"><span class="title">fun</span><span class="params">(pageOffset: <span class="typename">Int, itemsPerPage: Int</span>)</span>: Observable<span class="type">&lt;List&lt;PlaidItem&gt;</span>&gt; &#123;</span></span><br><span class="line">        <span class="keyword">return</span> backend.search(searchQuery, pageOffset).map(extractPlaidItemsFromStory)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a list with one single RouteCaller() with "searchCall" as method reference</span></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> callers</span> = arrayListOf(RouteCaller(<span class="number">0</span>, <span class="number">100</span>, searchCall))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAllBackendCallers</span><span class="params">()</span>: Observable<span class="type">&lt;List&lt;RouteCaller&lt;List&lt;PlaidItem&gt;</span>&gt;&gt;&gt; &#123;</span></span><br><span class="line">        <span class="keyword">return</span> Observable.just(callers)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你初学kotlin,乍一看 <code>DesignerNewsSearchCallerFactory</code> 有点奇怪,我们没有使用lambdas而是创建一个searchCall属性,实际上是一个函数 <code>(Int, Int) -&gt; Observable&lt;List&lt;PlaidItem&gt;&gt;</code>。</p>
<p>这样做是有原因的: 最近我看到Android团队在<code>Android2015开发者峰会</code>的谈话,被问到何时添加Java 8支持。<strong>Reto Meier</strong> 回答说,许多开发人员主要是对Lambdas 感兴趣, 当他问观众:想要Android加入Lambdas的请举手,然后几乎所有人举手了。我认为,对于Lambdas有一种普遍的误解: 提供Lambdasd的那些编程语言的真正强大不是 Lambdas,而是高阶函数和函数传递。lambdas 只不过是一个是匿名函数。实际上,Lambdas没有资格的,因为它们是硬编码的。例如,我还会实现这样的:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RouteCaller(<span class="number">0</span>, <span class="number">100</span>, &#123; pageOffset, limit -&gt; backend.search(searchQuery, pageOffset) &#125;)</span><br></pre></td></tr></table></figure>
<p>我们应该怎么写单元测试呢? 不可能给匿名函数写单元测试,因为它们是”硬编码的”,  然而,如果我们传递一个函数作为参数,那么很容易的为这个函数写一个单元测试. 在Java8中,传递一个函数参数这样写 <code>::searchCall</code>. 不幸的是, kotlin还不支持,目前仅仅支持静态方法,因此这里定义一个函数作为属性. 在这个系列文章的最后我会介绍一下我使用kotlin的体会.</p>
<p>好了,看一下”搜索”的结构</p>
<p><img src="http://hannesdorfmann.com/images/plaid/routing3.png" alt="RouteCallerFactory"></p>
<p>注意,<code>getAllBackendCallers()</code> 返回一个列表,其中包含一个RouteCaller,但这个想法是 RouteCallerFactory创建所有RouteCallers。稍后我们将看到,在Dribbble上RouteCallers HomeDribbbleCallerFactory返回一个RouteCaller的列表,代表每个端点加载item,如受欢迎的项目,最近的,动画等.</p>
<p><img src="http://hannesdorfmann.com/images/plaid/routing4.png" alt="RouteCallerFactory"></p>
<p>下面我们介绍<code>Router</code>, 它负责组合所有的 RouteCaller, 将不同的 RouteCallerFactories 返回一个单个的 Observable的list:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="variable"><span class="keyword">val</span> routeFactories</span>: List<span class="type">&lt;RouteCallerFactory&lt;T&gt;</span>&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllRoutes</span><span class="params">()</span>: Observable<span class="type">&lt;List&lt;RouteCaller&lt;T&gt;</span>&gt;&gt; &#123;</span></span><br><span class="line">        <span class="variable"><span class="keyword">val</span> callers</span> = ArrayList<span class="type">&lt;Observable&lt;List&lt;RouteCaller&lt;T&gt;</span>&gt;&gt;&gt;()</span><br><span class="line"></span><br><span class="line">        routeFactories.forEach &#123;</span><br><span class="line">            callers.add(it.getAllBackendCallers())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Observable.combineLatest(callers, &#123; calls -&gt;</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> items</span> = ArrayList<span class="type">&lt;RouteCaller&lt;T&gt;</span>&gt;(calls.size)</span><br><span class="line">            calls.forEach &#123;</span><br><span class="line">                items.addAll(it <span class="keyword">as</span> List<span class="type">&lt;RouteCaller&lt;T&gt;</span>&gt;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            items <span class="comment">// return items</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见Route 接收一个RouteCallerFactory列表,换句话说:通过构造函数可以配置Route。来完成“路由图”:</p>
<p><img src="http://hannesdorfmann.com/images/plaid/routing5.png" alt=""></p>
<p>好了,到目前为止,我们已经介绍了“Route 部分”。最后Router提供了一个 <code>Observable&lt;List&lt;RouteCaller&lt;T&gt;&gt;&gt;</code> 。但当我们最终在RecyclerView显示item的时候,这就是ItemsLoader的责任了。正如它的名字,该组件用来加载item:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemsLoader</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">protected</span> <span class="variable"><span class="keyword">val</span> router</span>: Router<span class="type">&lt;T&gt;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">firstPage</span><span class="params">()</span>: Observable<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">        <span class="keyword">return</span> FirstPage<span class="type">&lt;T&gt;</span>(router.getAllRoutes()).asObservable()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">olderPages</span><span class="params">()</span>: Observable<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">        <span class="keyword">return</span> OlderPage<span class="type">&lt;T&gt;</span>(router.getAllRoutes()).asObservable()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ItemsLoader</code> 接受一个 Router 作为构造函数的参数, 此外接受两个方法, firstPage()返回一个代表first page的Observable, olderPages()返回一个代表older pager的Observable.一个page代表RecyclerView显示的一页items,当我们滑动到底部加载下一页数据,看一下 page, FirstPage 和 OlderPage的代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="type">T</span>&gt;</span>(<span class="variable"><span class="keyword">val</span> routeCalls</span>: Observable<span class="type">&lt;List&lt;RouteCaller&lt;T&gt;</span>&gt;&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> failed</span> = AtomicInteger()</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> backendCallsCount</span>: <span class="typename">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Return an observable for this page</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asObservable</span><span class="params">()</span>: Observable<span class="type">&lt;T?&gt;</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> routeCalls.flatMap &#123; routeCalls -&gt;</span><br><span class="line"></span><br><span class="line">            backendCallsCount = routeCalls.size</span><br><span class="line">            <span class="variable"><span class="keyword">val</span> observables</span> = arrayListOf<span class="type">&lt;Observable&lt;T&gt;</span>&gt;()</span><br><span class="line">            routeCalls.forEach &#123; call -&gt;</span><br><span class="line">                    <span class="variable"><span class="keyword">val</span> observable</span> = getRouteCall(call).onErrorResumeNext &#123; error -&gt;</span><br><span class="line">                      <span class="comment">// Suppress errors as long as not all fail</span></span><br><span class="line">                        error.printStackTrace()</span><br><span class="line">                        <span class="variable"><span class="keyword">val</span> fails</span> = failed.incrementAndGet()</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (fails == backendCallsCount) &#123;</span><br><span class="line">                            Observable.error(error) <span class="comment">// All failed so emmit error</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Observable.empty() <span class="comment">// Not all failed, so ignore this error and emit nothing</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    observables.add(observable);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// return the created Observable</span></span><br><span class="line">                Observable.merge(observables)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> abstract <span class="function"><span class="keyword">fun</span> <span class="title">getRouteCall</span><span class="params">(caller: <span class="typename">RouteCaller&lt;T&gt;</span>)</span>: Observable<span class="type">&lt;T&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span>&lt;<span class="type">T</span>&gt;</span>(routeCalls: Observable<span class="type">&lt;List&lt;RouteCaller&lt;T&gt;</span>&gt;&gt;) : Page<span class="type">&lt;T&gt;</span>(routeCalls) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRouteCall</span><span class="params">(caller: <span class="typename">RouteCaller&lt;T&gt;</span>)</span>: Observable<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">        <span class="keyword">return</span> caller.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OlderPage</span>&lt;<span class="type">T</span>&gt;</span>(routeCalls: Observable<span class="type">&lt;List&lt;RouteCaller&lt;T&gt;</span>&gt;&gt;) : Page<span class="type">&lt;T&gt;</span>(routeCalls) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRouteCall</span><span class="params">(caller: <span class="typename">RouteCaller&lt;T&gt;</span>)</span>: Observable<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">        <span class="keyword">return</span> caller.getOlderWithRetry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Page 负责调用RouteCaller的方法来执行http请求,我们不希望因为某个后端的调用失败导致整个页面数据获取失败,因此我们使用 <code>onErrorResumeNext()</code> 来中断错误,然后返回一个http请求调用失败的 error.然后 <code>Presenter</code>通过<code>ItemsLoader</code> subscribe页面的 observable.</p>
<h2 id="依赖注入">依赖注入</h2><p>你可能注意到了,到目前为止几乎所有的组件都接受其他组件作为构造方法. 这是设计好的,现在我们使用 <code>Dagger</code>(我使用的 <code>Dagger1</code>) 来组合我们需要的元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span>(</span><br><span class="line">    injects = &#123;</span><br><span class="line">        HomePresenter.class</span><br><span class="line">    &#125;,</span><br><span class="line">    addsTo = ApplicationModule.class <span class="comment">// contains Retrofit interfaces</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> <span class="function">HomePresenter <span class="title">provideSearchPresenter</span><span class="params">(SourceDao sourceDao,</span><br><span class="line">      DribbbleService dribbbleBackend,</span><br><span class="line">      DesignerNewsService designerNewsBackend,</span><br><span class="line">      ProductHuntService productHuntBackend )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the router</span></span><br><span class="line">    List&lt;RouteCallerFactory&lt;List&lt;? extends PlaidItem&gt;&gt;&gt; routeCallerFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    routeCallerFactories.add(<span class="keyword">new</span> HomeDribbbleCallerFactory(dribbbleBackend, sourceDao));</span><br><span class="line">    routeCallerFactories.add(<span class="keyword">new</span> HomeDesingerNewsCallerFactory(designerNewsBackend, sourceDao));</span><br><span class="line">    routeCallerFactories.add(<span class="keyword">new</span> HomeProductHuntCallerFactory(productHuntBackend, sourceDao));</span><br><span class="line"></span><br><span class="line">    Router&lt;List&lt;? extends PlaidItem&gt;&gt; router = <span class="keyword">new</span> Router&lt;&gt;(routeCallerFactories);</span><br><span class="line"></span><br><span class="line">    ItemsLoader&lt;List&lt;? extends PlaidItem&gt;&gt; itemsLoader = <span class="keyword">new</span> ItemsLoader&lt;&gt;(router);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HomePresenterImpl(itemsLoader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见, 我们可以使用 <code>Dagger</code>来配置 <code>Router</code> 和 <code>ItemsLoader</code>. 我们给 <code>SearchModule</code>的<code>SearchPresenter</code>  配置一个 <code>ItemsLoader</code>和<code>Router</code>. 优势就是,如果有一天我们想要添加另一个“源”,如reddit,我们唯一要做的就是定义一个<code>RedditService</code>(Retrofit), <code>RedditCallerFactoy</code>并在<code>Router</code>中添加这个<code>CallerFactory</code>。我们可以在一个具体的 dagger module中,而不用修改其他类(开闭原则)。换句话说:我们已经通过依赖注入建立了一个可配置“插件系统”。<br>您可能已经注意到SourceDao类在上面所示的代码。我们将讨论在这个博客系列的第二部分中,当我们“真正的响应式”。</p>
<h2 id="第一部分总结">第一部分总结</h2><p>这是这个系列博客的第一篇.这篇文章中我们使用的MVP模式,并且重构了一下从后端加载数据的方法.主要任务就是将大的复杂的任务拆分成小的可重用的组件,如ItemsLoader, Page, Router and RouteCaller ,更加遵循 SOLID (Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion) 原则就如 DataManager 的实现.</p>
<p>总之,有更好的方法去实现这样一个app. 特别是 <code>ItemsLoader</code> 可以以完全不同的方式实现,我首先想到的是使用<code>RxJava</code>的 <code>SwitchOnNext()</code>或者 <code>merge</code>操作符去创建一个Observable去加载下一页数据. 但是,关于UI和错误处理,如果我可以单一观测分割成两个可见(first Page,older Page )会更容易实现</p>
<p>总之,欢迎提建议或反馈!<br>在第二部分, 我将使用<code>RxJava</code> 去重构Plaid 来实现一个 “真正reactive”的app.</p>
<blockquote>
<p>文章出处<a href="http://hanks.xyz">Hanks.xyz</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hanks.xyz/2015/12/08/refactoring-plaid-1/" data-id="cihy7es8t003sey050f638mnj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Refactoring/">Refactoring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rxjava/">Rxjava</a></li></ul>

    </footer>
  
  
</article>

  
<section id="comments">
    <!-- 多说分享框 -->
    <div class="ds-share flat" data-thread-key="/2015/12/08/refactoring-plaid-1/" data-title="重构 Plaid app - 响应式的MVP模式(一)" data-images="此处请替换为分享时显示的图片的链接地址" data-content="重构 Plaid app - 响应式的MVP模式(一)" data-url="http://hanks.xyz//2015/12/08/refactoring-plaid-1/">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">

      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
   </div>
    <!-- 多说评论框 start -->
   	<div class="ds-thread" data-thread-key="/2015/12/08/refactoring-plaid-1/" data-title="重构 Plaid app - 响应式的MVP模式(一)" data-url="http://hanks.xyz//2015/12/08/refactoring-plaid-1/"></div>
   <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
   <script type="text/javascript">
   var duoshuoQuery = {short_name:"hanks-zyh"};
   	(function() {
   		var ds = document.createElement('script');
   		ds.type = 'text/javascript';ds.async = true;
   		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
   		ds.charset = 'UTF-8';
   		(document.getElementsByTagName('head')[0]
   		 || document.getElementsByTagName('body')[0]).appendChild(ds);
   	})();
   	</script>
   <!-- 多说公共JS代码 end -->
</section>

</section>
      </div>
      <footer id="footer">
  
    <aside id="sidebar" class="outer">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/08/refactoring-plaid-1/">重构 Plaid app - 响应式的MVP模式(一)</a>
          </li>
        
          <li>
            <a href="/2015/12/06/rx_thread/">Rx中的线程切换</a>
          </li>
        
          <li>
            <a href="/2015/12/04/mac_java_enviroment/">OS X中Java环境变量配置</a>
          </li>
        
          <li>
            <a href="/2015/12/02/mac-os-in-Ubuntu/">Ubuntu 安装 OS X 10.11  虚拟机</a>
          </li>
        
          <li>
            <a href="/2015/12/01/ReactiveX/">ReactiveX</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/OS-X/" style="font-size: 10px;">OS X</a> <a href="/tags/Refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/Rx/" style="font-size: 10px;">Rx</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Rxandroid/" style="font-size: 10px;">Rxandroid</a> <a href="/tags/Rxjava/" style="font-size: 13.33px;">Rxjava</a> <a href="/tags/Ubuntu/" style="font-size: 16.67px;">Ubuntu</a> <a href="/tags/mac-os/" style="font-size: 10px;">mac os</a> <a href="/tags/virtualBox/" style="font-size: 10px;">virtualBox</a> <a href="/tags/必备知识/" style="font-size: 10px;">必备知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://kiya.space">kiya-z</a>
          </li>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
  
  <div class="outer footer_center">
    <div id="footer-info" class="inner">
      &copy; 2015 Hanks<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  </br>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    </div>
  </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/jquery.scrollLoading.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>